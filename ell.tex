\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*}{xcolor}
%
\documentclass[10pt,ignorenonframetext,serif,onlymath]{beamer}
\setbeamertemplate{caption}[numbered]
\setbeamertemplate{caption label separator}{: }
\setbeamercolor{caption name}{fg=normal text.fg}
\beamertemplatenavigationsymbolsempty
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
            pdftitle={Cutting-plane Method and Its Oracles},
            pdfauthor={Wai-Shing Luk},
            colorlinks=true,
            linkcolor=Maroon,
            citecolor=Blue,
            urlcolor=Blue,
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\newif\ifbibliography
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Prevent slide breaks in the middle of a paragraph:
\widowpenalties 1 10000
\raggedbottom
\setbeamertemplate{part page}{
\centering
\begin{beamercolorbox}[sep=16pt,center]{part title}
  \usebeamerfont{part title}\insertpart\par
\end{beamercolorbox}
}
\setbeamertemplate{section page}{
\centering
\begin{beamercolorbox}[sep=12pt,center]{part title}
  \usebeamerfont{section title}\insertsection\par
\end{beamercolorbox}
}
\setbeamertemplate{subsection page}{
\centering
\begin{beamercolorbox}[sep=8pt,center]{part title}
  \usebeamerfont{subsection title}\insertsubsection\par
\end{beamercolorbox}
}
\AtBeginPart{
  \frame{\partpage}
}
\AtBeginSection{
  \ifbibliography
  \else
    \frame{\sectionpage}
  \fi
}
\AtBeginSubsection{
  \frame{\subsectionpage}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\usetheme{default}
\usepackage{tikz,pgf,pgfplots}
\usetikzlibrary{arrows}
\definecolor{qqqqff}{rgb}{0.,0.,1.}
\newcommand{\columnsbegin}{\begin{columns}}
\newcommand{\columnsend}{\end{columns}}
\newcommand{\col}[1]{\column{#1}}
\pgfdeclareimage[height=0.5cm]{fudan-logo}{fudan-logo.jpg}
\logo{\pgfuseimage{fudan-logo}}

\title{Cutting-plane Method and Its Oracles}
\author{Wai-Shing Luk}
\providecommand{\institute}[1]{}
\institute{Fudan University}
\date{\today}

\begin{document}
\frame{\titlepage}

\begin{frame}
\tableofcontents[hideallsubsections]
\end{frame}
\begin{frame}

\begin{quote}
When you have eliminated the impossible, whatever remains, however
improbable, must be the truth.
\end{quote}

\emph{Sir Arthur Conan Doyle, stated by Sherlock Holmes}

\end{frame}

\hypertarget{sec:introduction}{%
\section{Introduction}\label{sec:introduction}}

\begin{frame}{Some History of Ellipsoid Method}
\protect\hypertarget{sec:some-history-of-ellipsoid-method}{}

\begin{itemize}
\item
  Introduced by Shor and Yudin and Nemirovskii in 1976
\item
  Used to show that linear programming (LP) is polynomial-time solvable
  (Kachiyan 1979), settled the long-standing problem of determining the
  theoretically complexity of LP.
\item
  In practice, however, the simplex method runs much faster than the
  method, although its worst-case complexity is exponential.
\end{itemize}

\end{frame}

\begin{frame}{Common Perspective of Ellipsoid Method}
\protect\hypertarget{sec:common-perspective-of-ellipsoid-method}{}

\begin{itemize}
\item
  It is commonly believed that it is inefficient in practice for
  large-scale problems.

  \begin{itemize}
  \item
    The convergent rate is slow, even with the use of deep cuts.
  \item
    Cannot exploit sparsity.
  \end{itemize}
\item
  Since then, it was supplanted by interior-point methods.
\item
  Only treated as a theoretical tool for proving the polynomial-time
  solvability of combinatorial optimization problems.
\end{itemize}

\end{frame}

\begin{frame}{But\ldots{}}
\protect\hypertarget{sec:but}{}

\begin{itemize}
\item
  The ellipsoid method works very differently compared with the interior
  point method.
\item
  Only require a cutting-plane oracle. Can play nicely with other
  techniques.
\item
  The oracle can exploit sparsity.
\end{itemize}

\end{frame}

\begin{frame}{Consider Ellipsoid Method When\ldots{}}
\protect\hypertarget{sec:consider-ellipsoid-method-when}{}

\begin{itemize}
\item
  The number of optimization variables is moderate, e.g.~ECO flow,
  analog circuit sizing, parametric problems
\item
  The number of constraints is large, or even infinite
\item
  Oracle can be implemented efficiently.
\end{itemize}

\end{frame}

\hypertarget{sec:cutting-plane-method-revisited}{%
\section{Cutting-plane Method
Revisited}\label{sec:cutting-plane-method-revisited}}

\begin{frame}{Basic Idea}
\protect\hypertarget{sec:basic-idea}{}

\begin{columns}

\column{0.6\textwidth}

\begin{itemize}
\tightlist
\item
  Let \(\mathcal{K} \subseteq \mathbb{R}^n\) be a convex set.
\item
  Consider the feasibility problem:

  \begin{itemize}
  \tightlist
  \item
    Find a point \(x^* \in \mathbb{R}^n\) in \(\mathcal{K}\),
  \item
    or determine that \(\mathcal{K}\) is empty (i.e., no feasible sol’n)
  \end{itemize}
\end{itemize}

\column{0.4\textwidth}

\includegraphics{ellipsoid.files/region.pdf}

\end{columns}

\end{frame}

\begin{frame}{Cutting-plane Oracle}
\protect\hypertarget{sec:cutting-plane-oracle}{}

\begin{columns}

\column{0.6\textwidth}

\begin{itemize}
\tightlist
\item
  When cutting-plane oracle \(\Omega\) is \emph{queried} at \(x_0\), it
  either

  \begin{itemize}
  \tightlist
  \item
    asserts that \(x_0 \in \mathcal{K}\), or
  \item
    returns a separating hyperplane between \(x_0\) and \(\mathcal{K}\):
    \[g^\mathsf{T} (x - x_0) + h \leq 0, h \geq 0, g \neq 0, \;
          \forall x \in \mathcal{K}\]
  \end{itemize}
\end{itemize}

\column{0.4\textwidth}

\includegraphics{ellipsoid.files/cut.pdf}

\end{columns}

\end{frame}

\begin{frame}{Cutting-plane oracle (cont’d)}
\protect\hypertarget{sec:cutting-plane-oracle-contd}{}

\begin{itemize}
\item
  \((g,h)\) called a \emph{cutting-plane}, or cut, since it eliminates
  the halfspace \(\{x \mid g^\mathsf{T} (x - x_0) + h > 0\}\) from our search.
\item
  If \(h=0\) (\(x_0\) is on boundary of halfspace that is cut),
  cutting-plane is called \emph{neutral cut}.
\item
  If \(h>0\) (\(x_0\) lies in interior of halfspace that is cut),
  cutting-plane is called \emph{deep cut}.
\end{itemize}

\end{frame}

\begin{frame}{Subgradient}
\protect\hypertarget{sec:subgradient}{}

\begin{itemize}
\tightlist
\item
  \(\mathcal{K}\) is usually given by a set of inequalities
  \(f_j(x) \le 0\) or \(f_j(x) < 0\) for \(j = 1 \cdots m\), where
  \(f_j(x)\) is a convex function.
\item
  A vector \(g \equiv \partial f(x_0)\) is called a subgradient of a
  convex function \(f\) at \(x_0\) if
  \(f(z) \geq f(x_0) + g^\mathrm{T} (z - x_0)\).
\item
  Hence, the cut \((g, h)\) is given by \((\partial f(x_0), f(x_0))\)
\end{itemize}

Remarks:

\begin{itemize}
\tightlist
\item
  If \(f(x)\) is differentiable, we can simply take
  \(\partial f(x_0) = \nabla f(x_0)\)
\end{itemize}

\end{frame}

\begin{frame}{Key components of Cutting-plane method}
\protect\hypertarget{sec:key-components-of-cutting-plane-method}{}

\begin{itemize}
\tightlist
\item
  Cutting plane oracle \(\Omega\)
\item
  A search space \(\mathcal{S}\) initially big enough to cover
  \(\mathcal{K}\), e.g.

  \begin{itemize}
  \tightlist
  \item
    Polyhedron \(\mathcal{P}\) = \(\{z \mid C z \preceq d \}\)
  \item
    Interval \(\mathcal{I}\) = \([l, u]\) (for one-dimensional problem)
  \item
    Ellipsoid \(\mathcal{E}\) =
    \(\{z \mid (z-x_c)P^{-1}(z-x_c) \leq 1 \}\)
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{Generic Cutting-plane method}
\protect\hypertarget{sec:generic-cutting-plane-method}{}

\begin{itemize}
\tightlist
\item
  \textbf{Given} initial \(\mathcal{S}\) known to contain
  \(\mathcal{K}\).
\item
  \textbf{Repeat}

  \begin{enumerate}
  [1.]
  \tightlist
  \item
    Choose a point \(x_0\) in \(\mathcal{S}\)
  \item
    Query the cutting-plane oracle at \(x_0\)
  \item
    \textbf{If} \(x_0 \in \mathcal{K}\), quit
  \item
    \textbf{Else}, update \(\mathcal{S}\) to a smaller set that covers:
    \[\mathcal{S}^+ = \mathcal{S} \cap \{z \mid g^\mathsf{T} (z - x_0) + h \leq 0\}\]
  \item
    \textbf{If} \(\mathcal{S}^+ = \emptyset\) or it is small enough,
    quit.
  \end{enumerate}
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Python code}
\protect\hypertarget{sec:python-code}{}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ cutting_plane_feas(evaluate, S, options}\OperatorTok{=}\NormalTok{Options()):}
\NormalTok{    feasible }\OperatorTok{=} \VariableTok{False}
\NormalTok{    status }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ niter }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(options.max_it):}
\NormalTok{        cut, feasible }\OperatorTok{=}\NormalTok{ evaluate(S.xc)}
        \ControlFlowTok{if}\NormalTok{ feasible:  }\CommentTok{# feasible sol'n obtained}
            \ControlFlowTok{break}
\NormalTok{        status, tau }\OperatorTok{=}\NormalTok{ S.update(cut)}
        \ControlFlowTok{if}\NormalTok{ status }\OperatorTok{!=} \DecValTok{0}\NormalTok{:}
            \ControlFlowTok{break}
        \ControlFlowTok{if}\NormalTok{ tau }\OperatorTok{<}\NormalTok{ options.tol:}
\NormalTok{            status }\OperatorTok{=} \DecValTok{2}
            \ControlFlowTok{break}
    \ControlFlowTok{return}\NormalTok{ S.xc, niter}\OperatorTok{+}\DecValTok{1}\NormalTok{, feasible, status}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Convex Optimization Problem (I)}
\protect\hypertarget{sec:convex-optimization-problem-i}{}

\[\begin{array}{ll}
    \text{minimize}     & f_0(x), \\
    \text{subject to}   & x \in \mathcal{K}
\end{array}\]

\begin{itemize}
\item
  The optimization problem is treated as a feasibility problem with an
  additional constraint \(f_0(x) < t\)
\item
  \(f_0(x)\) could be a convex function or a quasiconvex function.
\item
  \(t\) is the best-so-far value of \(f_0(x)\).
\end{itemize}

\end{frame}

\begin{frame}{Convex Optimization Problem (II)}
\protect\hypertarget{sec:convex-optimization-problem-ii}{}

\begin{itemize}
\item
  Problem formulation: \[\begin{array}{ll}
              \text{find}         & x, \\
              \text{subject to}   & \Phi_t(x) < 0 \\
                                  & x \in \mathcal{K}
    \end{array}\] where \(\Phi_t(x) < 0\) is the \(t\)-sublevel set of
  \(f_0(x)\).
\item
  Note: \(\mathcal{K}_t \subseteq \mathcal{K}_u\) if and only if
  \(t \leq u\) (monotonicity)
\item
  One easy way to solve the optimization problem is to apply the binary
  search on \(t\).
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Python code}
\protect\hypertarget{sec:python-code-1}{}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ bsearch(evaluate, I, options}\OperatorTok{=}\NormalTok{Options()):}
    \CommentTok{# assume monotone}
\NormalTok{    feasible }\OperatorTok{=} \VariableTok{False}
\NormalTok{    l, u }\OperatorTok{=}\NormalTok{ I}
\NormalTok{    t }\OperatorTok{=}\NormalTok{ l }\OperatorTok{+}\NormalTok{ (u }\OperatorTok{-}\NormalTok{ l)}\OperatorTok{/}\DecValTok{2}
    \ControlFlowTok{for}\NormalTok{ niter }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(options.max_it):}
        \ControlFlowTok{if}\NormalTok{ evaluate(t):  }\CommentTok{# feasible sol'n obtained}
\NormalTok{            feasible }\OperatorTok{=} \VariableTok{True}
\NormalTok{            u }\OperatorTok{=}\NormalTok{ t}
        \ControlFlowTok{else}\NormalTok{:}
\NormalTok{            l }\OperatorTok{=}\NormalTok{ t}
\NormalTok{        tau }\OperatorTok{=}\NormalTok{ (u }\OperatorTok{-}\NormalTok{ l)}\OperatorTok{/}\DecValTok{2}
\NormalTok{        t }\OperatorTok{=}\NormalTok{ l }\OperatorTok{+}\NormalTok{ tau}
        \ControlFlowTok{if}\NormalTok{ tau }\OperatorTok{<}\NormalTok{ options.tol:}
            \ControlFlowTok{break}
    \ControlFlowTok{return}\NormalTok{ u, niter}\OperatorTok{+}\DecValTok{1}\NormalTok{, feasible}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}[fragile]

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ bsearch_adaptor:}
    \KeywordTok{def} \FunctionTok{__init__}\NormalTok{(}\VariableTok{self}\NormalTok{, P, E, options}\OperatorTok{=}\NormalTok{Options()):}
        \VariableTok{self}\NormalTok{.P }\OperatorTok{=}\NormalTok{ P}
        \VariableTok{self}\NormalTok{.E }\OperatorTok{=}\NormalTok{ E}
        \VariableTok{self}\NormalTok{.options }\OperatorTok{=}\NormalTok{ options}

    \AttributeTok{@property}
    \KeywordTok{def}\NormalTok{ x_best(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.E.xc}

    \KeywordTok{def} \FunctionTok{__call__}\NormalTok{(}\VariableTok{self}\NormalTok{, t):}
\NormalTok{        E }\OperatorTok{=} \VariableTok{self}\NormalTok{.E.copy()}
        \VariableTok{self}\NormalTok{.P.update(t)}
\NormalTok{        x, _, feasible, _ }\OperatorTok{=}\NormalTok{ cutting_plane_feas(}
            \VariableTok{self}\NormalTok{.P, E, }\VariableTok{self}\NormalTok{.options)}
        \ControlFlowTok{if}\NormalTok{ feasible:}
            \VariableTok{self}\NormalTok{.E._xc }\OperatorTok{=}\NormalTok{ x.copy()}
            \ControlFlowTok{return} \VariableTok{True}
        \ControlFlowTok{return} \VariableTok{False}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}

\begin{itemize}
\tightlist
\item
  Another possible way is, to update the best-so-far \(t\) whenever a
  feasible sol’n \(x_0\) is found such that \(\Phi_t(x_0) = 0\).
\item
  We assume that the oracle takes the responsbility for that.
\end{itemize}

\end{frame}

\begin{frame}{Generic Cutting-plane method (Optim)}
\protect\hypertarget{sec:generic-cutting-plane-method-optim}{}

\begin{itemize}
\tightlist
\item
  \textbf{Given} initial \(\mathcal{S}\) known to contain
  \(\mathcal{K}_t\).
\item
  \textbf{Repeat}

  \begin{enumerate}
  [1.]
  \tightlist
  \item
    Choose a point \(x_0\) in \(\mathcal{S}\)
  \item
    Query the cutting-plane oracle at \(x_0\)
  \item
    \textbf{If} \(x_0 \in \mathcal{K}_t\), update \(t\) such that
    \(\Phi_t(x_0) = 0\).
  \item
    Update \(\mathcal{S}\) to a smaller set that covers:
    \[\mathcal{S}^+ = \mathcal{S} \cap \{z \mid g^\mathsf{T} (z - x_0) + h \leq 0\} \]
  \item
    \textbf{If} \(\mathcal{S}^+ = \emptyset\) or it is small enough,
    quit.
  \end{enumerate}
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Python code}
\protect\hypertarget{sec:python-code-2}{}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ cutting_plane_dc(evaluate, S, t, options}\OperatorTok{=}\NormalTok{Options()):}
\NormalTok{    feasible }\OperatorTok{=} \VariableTok{False}  \CommentTok{# no sol'n}
\NormalTok{    x_best }\OperatorTok{=}\NormalTok{ S.xc}
    \ControlFlowTok{for}\NormalTok{ niter }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(options.max_it):}
\NormalTok{        cut, t1 }\OperatorTok{=}\NormalTok{ evaluate(S.xc, t)}
        \ControlFlowTok{if}\NormalTok{ t }\OperatorTok{!=}\NormalTok{ t1:  }\CommentTok{# best t obtained}
\NormalTok{            feasible }\OperatorTok{=} \VariableTok{True}
\NormalTok{            t }\OperatorTok{=}\NormalTok{ t1}
\NormalTok{            x_best }\OperatorTok{=}\NormalTok{ S.xc}
\NormalTok{        status, tau }\OperatorTok{=}\NormalTok{ S.update(cut)}
        \ControlFlowTok{if}\NormalTok{ status }\OperatorTok{==} \DecValTok{1}\NormalTok{:}
            \ControlFlowTok{break}
        \ControlFlowTok{if}\NormalTok{ tau }\OperatorTok{<}\NormalTok{ options.tol:}
\NormalTok{            status }\OperatorTok{=} \DecValTok{2}
            \ControlFlowTok{break}
    \ControlFlowTok{return}\NormalTok{ x_best, t, niter}\OperatorTok{+}\DecValTok{1}\NormalTok{, feasible, status}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Example: Profit Maximization Problem}
\protect\hypertarget{sec:example-profit-maximization-problem}{}

\[\begin{array}{ll}
   \text{maximize} & p(A x_1^\alpha x_2^\beta) - v_1 x_1 - v_2 x_2 \\
   \text{subject to}& x_1 \le k.
\end{array}\]

\begin{itemize}
\tightlist
\item
  \(p(A x_1^\alpha x_2^\beta)\) : Cobb-Douglas production function
\item
  \(p\): the market price per unit
\item
  \(A\): the scale of production
\item
  \(\alpha, \beta\): the output elasticities
\item
  \(x\): input quantity
\item
  \(v\): output price
\item
  \(k\): a given constant that restricts the quantity of \(x_1\)
\end{itemize}

\end{frame}

\begin{frame}{Example: Profit maximization (cont’d)}
\protect\hypertarget{sec:example-profit-maximization-contd}{}

\begin{itemize}
\tightlist
\item
  The formulation is not in the convex form.
\item
  Rewrite the problem in the following form: \[\begin{array}{ll}
    \text{maximize} & t \\
    \text{subject to} & t  + v_1 x_1  + v_2 x_2 < p A x_1^{\alpha} x_2^{\beta}\\
                  & x_1 \le k.
    \end{array}\]
\end{itemize}

\end{frame}

\begin{frame}{Profit maximization in Convex Form}
\protect\hypertarget{sec:profit-maximization-in-convex-form}{}

\begin{itemize}
\item
  Change variables to:

  \begin{itemize}
  \tightlist
  \item
    \(y_1 = \log x_1\), \(y_2 = \log x_2\).
  \end{itemize}
\end{itemize}

and take logarithm of cost and constraints.

\begin{itemize}
\tightlist
\item
  We have the problem in a convex form: \[\begin{array}{ll}
    \text{max}  & t \\
    \text{s.t.} & \log(t + v_1 e^{y_1} + v_2 e^{y_2}) - (\alpha y_1 + \beta y_2) < \log(pA)  \\
                  & y_1 \le \log k ,
    \end{array}\]
\end{itemize}

\end{frame}

\begin{frame}[fragile,allowframebreaks]{Python code (Profit oracle)}
\protect\hypertarget{sec:python-code-profit-oracle}{}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ profit_oracle:}
    \KeywordTok{def} \FunctionTok{__init__}\NormalTok{(}\VariableTok{self}\NormalTok{, params, a, v):}
\NormalTok{        p, A, k }\OperatorTok{=}\NormalTok{ params}
        \VariableTok{self}\NormalTok{.log_pA }\OperatorTok{=}\NormalTok{ np.log(p }\OperatorTok{*}\NormalTok{ A)}
        \VariableTok{self}\NormalTok{.log_k }\OperatorTok{=}\NormalTok{ np.log(k)}
        \VariableTok{self}\NormalTok{.v }\OperatorTok{=}\NormalTok{ v}\OperatorTok{;} \VariableTok{self}\NormalTok{.a }\OperatorTok{=}\NormalTok{ a}

    \KeywordTok{def} \FunctionTok{__call__}\NormalTok{(}\VariableTok{self}\NormalTok{, y, t):}
\NormalTok{        fj }\OperatorTok{=}\NormalTok{ y[}\DecValTok{0}\NormalTok{] }\OperatorTok{-} \VariableTok{self}\NormalTok{.log_k  }\CommentTok{# constraint}
        \ControlFlowTok{if}\NormalTok{ fj }\OperatorTok{>} \FloatTok{0.}\NormalTok{:}
\NormalTok{            g }\OperatorTok{=}\NormalTok{ np.array([}\FloatTok{1.}\NormalTok{, }\FloatTok{0.}\NormalTok{])}
            \ControlFlowTok{return}\NormalTok{ (g, fj), t}
\NormalTok{        log_Cobb }\OperatorTok{=} \VariableTok{self}\NormalTok{.log_pA }\OperatorTok{+}\NormalTok{ np.dot(}\VariableTok{self}\NormalTok{.a, y)}
\NormalTok{        x }\OperatorTok{=}\NormalTok{ np.exp(y)}
\NormalTok{        vx }\OperatorTok{=}\NormalTok{ np.dot(}\VariableTok{self}\NormalTok{.v, x)}
\NormalTok{        te }\OperatorTok{=}\NormalTok{ t }\OperatorTok{+}\NormalTok{ vx}
\NormalTok{        fj }\OperatorTok{=}\NormalTok{ np.log(te) }\OperatorTok{-}\NormalTok{ log_Cobb}
        \ControlFlowTok{if}\NormalTok{ fj }\OperatorTok{<} \FloatTok{0.}\NormalTok{:}
\NormalTok{            te }\OperatorTok{=}\NormalTok{ np.exp(log_Cobb)}
\NormalTok{            t }\OperatorTok{=}\NormalTok{ te }\OperatorTok{-}\NormalTok{ vx}\OperatorTok{;}\NormalTok{ fj }\OperatorTok{=} \FloatTok{0.}
\NormalTok{        g }\OperatorTok{=}\NormalTok{ (}\VariableTok{self}\NormalTok{.v }\OperatorTok{*}\NormalTok{ x) }\OperatorTok{/}\NormalTok{ te }\OperatorTok{-} \VariableTok{self}\NormalTok{.a}
        \ControlFlowTok{return}\NormalTok{ (g, fj), t}

\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{from}\NormalTok{ cutting_plane }\ImportTok{import} \OperatorTok{*}
\ImportTok{from}\NormalTok{ ell }\ImportTok{import} \OperatorTok{*}

\NormalTok{p, A, k }\OperatorTok{=} \FloatTok{20.0}\NormalTok{, }\FloatTok{40.0}\NormalTok{, }\FloatTok{30.5}
\NormalTok{params }\OperatorTok{=}\NormalTok{ p, A, k}
\NormalTok{alpha, beta }\OperatorTok{=} \FloatTok{0.1}\NormalTok{, }\FloatTok{0.4}
\NormalTok{v1, v2 }\OperatorTok{=} \FloatTok{10.0}\NormalTok{, }\FloatTok{35.0}
\NormalTok{y0 }\OperatorTok{=}\NormalTok{ np.array([}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.0}\NormalTok{])  }\CommentTok{# initial x0}
\NormalTok{E }\OperatorTok{=}\NormalTok{ ell(}\DecValTok{200}\NormalTok{, y0)}
\NormalTok{P }\OperatorTok{=}\NormalTok{ profit_oracle(params, alpha, beta, v1, v2)}
\NormalTok{yb1, fb, }\BuiltInTok{iter}\NormalTok{, feasible, status }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    cutting_plane_dc(P, E, }\FloatTok{0.0}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(fb, }\BuiltInTok{iter}\NormalTok{, feasible, status)}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Area of Applications}
\protect\hypertarget{sec:area-of-applications}{}

\begin{itemize}
\tightlist
\item
  Robust convex optimization

  \begin{itemize}
  \tightlist
  \item
    oracle technique: affine arithmetic
  \end{itemize}
\item
  Parametric network potential problem

  \begin{itemize}
  \tightlist
  \item
    oracle technique: negative cycle detection
  \end{itemize}
\item
  Semidefinite programming

  \begin{itemize}
  \tightlist
  \item
    oracle technique: Cholesky factorization
  \end{itemize}
\end{itemize}

\end{frame}

\hypertarget{sec:robust-convex-optimization}{%
\section{Robust Convex
Optimization}\label{sec:robust-convex-optimization}}

\begin{frame}{Robust Optimization Formulation}
\protect\hypertarget{sec:robust-optimization-formulation}{}

\begin{itemize}
\item
  Consider: \[\begin{array}{ll}
      \text{minimize}   & \sup_{q \in {\mathbb{Q}}} f_0(x,q) \\
      \text{subject to} & f_j(x,q) \leq 0 \qquad \\
      & \forall q \in {\mathbb{Q}} \; \text{and} \; j = 1,2,\cdots,m,
    \end{array}\] where \(q\) represents a set of varying parameters.
\item
  The problem can be reformulated as: \[\begin{array}{ll}
      \text{minimize}   & t \\
      \text{subject to} & f_0(x,q) < t  \\
      & f_j(x,q) \leq 0 \\
      & \forall q \in {\mathbb{Q}} \; \text{and} \; j = 1,2,\cdots,m,
    \end{array}\]
\end{itemize}

\end{frame}

\begin{frame}{Oracle in Robust Optimization Formulation}
\protect\hypertarget{sec:oracle-in-robust-optimization-formulation}{}

\begin{itemize}
\tightlist
\item
  The oracle only needs to determine:

  \begin{itemize}
  \tightlist
  \item
    If \(f_j(x_0, q) > 0\) for some \(j\) and \(q = q_0\), then

    \begin{itemize}
    \tightlist
    \item
      the cut \((g, h)\) = \((\partial f_j(x_0, q_0), f_j(x_0, q_0))\)
    \end{itemize}
  \item
    If \(f_0(x_0, q) \geq t\) for some \(q = q_0\), then

    \begin{itemize}
    \tightlist
    \item
      the cut \((g, h)\) =
      \((\partial f_0(x_0, q_0), f_0(x_0, q_0) - t)\)
    \end{itemize}
  \item
    Otherwise, \(x_0\) is feasible, then

    \begin{itemize}
    \tightlist
    \item
      Let \(q_{\max} = \text{argmax}_{q \in {\mathbb{Q}}} f_0(x_0, q)\).
    \item
      \(t := f_0(x_0, q_{\max})\).
    \item
      The cut \((g, h)\) = \((\partial f_0(x_0, q_{\max}), 0)\)
    \end{itemize}
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{Example: Profit Maximization Problem (convex)}
\protect\hypertarget{sec:example-profit-maximization-problem-convex}{}

\[\begin{array}{ll}
\text{max}  & t \\
\text{s.t.} & \log(t + \hat{v}_1 e^{y_1} + \hat{v}_2 e^{y_2}) - (\hat{\alpha} y_1 + \hat{\beta} y_2) \le \log(\hat{p}\,A)  \\
                  & y_1 \le \log \hat{k} ,
\end{array}\]

\begin{itemize}
\tightlist
\item
  Now assume that:

  \begin{itemize}
  \tightlist
  \item
    \(\hat{\alpha}\) and \(\hat{\beta}\) vary \(\bar{\alpha} \pm e_1\)
    and \(\bar{\beta} \pm e_2\) respectively.
  \item
    \(\hat{p}\), \(\hat{k}\), \(\hat{v}_1\), and \(\hat{v}_2\) all vary
    \(\pm e_3\).
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{Example: Profit Maximization Problem (oracle)}
\protect\hypertarget{sec:example-profit-maximization-problem-oracle}{}

By detail analysis, the worst case happens when:

\begin{itemize}
\tightlist
\item
  \(p = \bar{p} + e_3\), \(k = \bar{k} + e_3\)
\item
  \(v_1 = \bar{v}_1 - e_3\), \(v_2 = \bar{v}_2 - e_3\),
\item
  if \(y_1 > 0\), \(\alpha = \bar{\alpha} - e_1\), else
  \(\alpha = \bar{\alpha} + e_1\)
\item
  if \(y_2 > 0\), \(\beta = \bar{\beta} - e_2\), else
  \(\beta = \bar{\beta} + e_2\)
\end{itemize}

\textbf{Remark}: for more complicated problems, affine arithmetic could
be used.

\end{frame}

\begin{frame}[fragile]{\texttt{profit\_rb\_oracle}}
\protect\hypertarget{sec:profit_rb_oracle}{}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ profit_rb_oracle:}
    \KeywordTok{def} \FunctionTok{__init__}\NormalTok{(}\VariableTok{self}\NormalTok{, params, a, v, vparams):}
\NormalTok{        ui, e1, e2, e3 }\OperatorTok{=}\NormalTok{ vparams}
        \VariableTok{self}\NormalTok{.uie }\OperatorTok{=}\NormalTok{ [ui }\OperatorTok{*}\NormalTok{ e1, ui }\OperatorTok{*}\NormalTok{ e2]}
        \VariableTok{self}\NormalTok{.a }\OperatorTok{=}\NormalTok{ a}\OperatorTok{;}\NormalTok{ p, A, k }\OperatorTok{=}\NormalTok{ params}
\NormalTok{        p }\OperatorTok{-=}\NormalTok{ ui }\OperatorTok{*}\NormalTok{ e3}\OperatorTok{;}\NormalTok{ k }\OperatorTok{-=}\NormalTok{ ui }\OperatorTok{*}\NormalTok{ e3}
\NormalTok{        v_rb }\OperatorTok{=}\NormalTok{ v.copy()}
\NormalTok{        v_rb }\OperatorTok{+=}\NormalTok{ ui }\OperatorTok{*}\NormalTok{ e3}
        \VariableTok{self}\NormalTok{.P }\OperatorTok{=}\NormalTok{ profit_oracle((p, A, k), a, v_rb)}

    \KeywordTok{def} \FunctionTok{__call__}\NormalTok{(}\VariableTok{self}\NormalTok{, y, t):}
\NormalTok{        a_rb }\OperatorTok{=} \VariableTok{self}\NormalTok{.a.copy()}
        \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{2}\NormalTok{):}
\NormalTok{            a_rb[i] }\OperatorTok{+=} \VariableTok{self}\NormalTok{.uie[i] }\OperatorTok{*}\NormalTok{ (}\OperatorTok{+}\FloatTok{1.}
                        \ControlFlowTok{if}\NormalTok{ y[i] }\OperatorTok{<=} \FloatTok{0.} \ControlFlowTok{else} \FloatTok{-1.}\NormalTok{)}
        \VariableTok{self}\NormalTok{.P.a }\OperatorTok{=}\NormalTok{ a_rb}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.P(y, t)}
\end{Highlighting}
\end{Shaded}

\end{frame}

\hypertarget{sec:parametric-network-potential-problem}{%
\section{Parametric Network Potential
Problem}\label{sec:parametric-network-potential-problem}}

\begin{frame}{Parametric Network Potential Problem}
\protect\hypertarget{sec:parametric-network-potential-problem-1}{}

Given a network represented by a graph \(G = (V, E)\). Consider

\[\begin{array}{ll}
    \text{minimize} & f_0(x) \\
    \text{subject to} & u_i - u_j \le h_{ij}(x), \; \forall (i, j) \in E ,\\
    \text{variables} &x, u ,
   \end{array}\]

\begin{itemize}
\item
  \(h_{ij}(x)\) is the weight function of edge \((i,j)\),
\item
  Assume: network is large but the number of parameters is small.
\end{itemize}

\end{frame}

\begin{frame}{Network Potential Problem (cont’d)}
\protect\hypertarget{sec:network-potential-problem-contd}{}

Given \(x_0\), the problem has a feasible solution if and only if \(G\)
contains no negative cycle. Let \(\mathcal{C}\) be a set of all cycles
of \(G\).

\[\begin{array}{ll}
    \text{minimize} & f_0(x) \\
    \text{subject to} & W_k(x) \ge 0, \forall C_k \in C ,\\
       \text{variables} & x
   \end{array}\]

\begin{itemize}
\item
  \(C_k\) is a cycle of \(G\)
\item
  \(W_k(x) = \sum_{ (i,j)\in C_k} h_{ij}(x)\).
\end{itemize}

\end{frame}

\begin{frame}{Oracle in Network Potential Problem}
\protect\hypertarget{sec:oracle-in-network-potential-problem}{}

\begin{itemize}
\tightlist
\item
  The oracle only needs to determine:

  \begin{itemize}
  \tightlist
  \item
    If there exists a negative cycle \(C_k\) under \(x_0\), then

    \begin{itemize}
    \tightlist
    \item
      the cut \((g, h)\) = \((-\partial W_k(x_0), -W_k(x_0))\)
    \end{itemize}
  \item
    If \(f_0(x_0) \geq t\), then

    \begin{itemize}
    \tightlist
    \item
      the cut \((g, h)\) = \((\partial f_0(x_0), f_0(x_0) - t)\)
    \end{itemize}
  \item
    Otherwise, \(x_0\) is feasible, then

    \begin{itemize}
    \tightlist
    \item
      \(t := f_0(x_0)\).
    \item
      The cut \((g, h)\) = \((\partial f_0(x_0), 0)\)
    \end{itemize}
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}[fragile]

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ network_oracle:}
    \KeywordTok{def} \FunctionTok{__init__}\NormalTok{(}\VariableTok{self}\NormalTok{, G, f, p):}
        \VariableTok{self}\NormalTok{.G }\OperatorTok{=}\NormalTok{ G}
        \VariableTok{self}\NormalTok{.f }\OperatorTok{=}\NormalTok{ f}
        \VariableTok{self}\NormalTok{.p }\OperatorTok{=}\NormalTok{ p  }\CommentTok{# partial derivative of f w.r.t x}
        \VariableTok{self}\NormalTok{.S }\OperatorTok{=}\NormalTok{ negCycleFinder(G)}

    \KeywordTok{def} \FunctionTok{__call__}\NormalTok{(}\VariableTok{self}\NormalTok{, x):}
        \KeywordTok{def}\NormalTok{ get_weight(G, e):}
            \ControlFlowTok{return} \VariableTok{self}\NormalTok{.f(G, e, x)}

        \VariableTok{self}\NormalTok{.S.get_weight }\OperatorTok{=}\NormalTok{ get_weight}
\NormalTok{        C }\OperatorTok{=} \VariableTok{self}\NormalTok{.S.find_neg_cycle()}
        \ControlFlowTok{if}\NormalTok{ C }\KeywordTok{is} \VariableTok{None}\NormalTok{:}
            \ControlFlowTok{return} \VariableTok{None}\NormalTok{, }\DecValTok{1}
\NormalTok{        f }\OperatorTok{=} \OperatorTok{-}\BuiltInTok{sum}\NormalTok{(}\VariableTok{self}\NormalTok{.f(}\VariableTok{self}\NormalTok{.G, e, x) }\ControlFlowTok{for}\NormalTok{ e }\KeywordTok{in}\NormalTok{ C)}
\NormalTok{        g }\OperatorTok{=} \OperatorTok{-}\BuiltInTok{sum}\NormalTok{(}\VariableTok{self}\NormalTok{.p(}\VariableTok{self}\NormalTok{.G, e, x) }\ControlFlowTok{for}\NormalTok{ e }\KeywordTok{in}\NormalTok{ C)}
        \ControlFlowTok{return}\NormalTok{ (g, f), }\DecValTok{0}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Example: Optimal Matrix Scaling}
\protect\hypertarget{sec:example-optimal-matrix-scaling}{}

\begin{itemize}
\item
  Given a sparse matrix \(A = [a_{ij}] \in \mathbb{R}^{N\times N}\).
\item
  Find another matrix \(B = U A U^{-1}\) where \(U\) is a nonnegative
  diagonal matrix, such that the ratio of any two elements of \(B\) in
  absolute value is as close to 1 as possible.
\item
  Let \(U = \mathrm{diag}([u_1, u_2, \ldots, u_N])\). Under the
  min-max-ratio criterion, the problem can be formulated as:
\end{itemize}

\[\begin{array}{ll}
  \text{minimize}   &   \pi/\psi  \\
  \text{subject to} &   \psi \leq u_i |a_{ij}| u_j^{-1} \leq \pi, \; \forall a_{ij} \neq 0 , \\
                    &   \pi, \, \psi, u, \text{positive} \\
  \text{variables}  &   \pi, \psi, u \, .
  \end{array}\]

\end{frame}

\begin{frame}{Optimal Matrix Scaling (cont’d)}
\protect\hypertarget{sec:optimal-matrix-scaling-contd}{}

By taking logarithms of variables, the above problem can be transformed
into:

\[\begin{array}{ll}
  \text{minimize}   &   \pi' - \psi'  \\
  \text{subject to} &   u_i' -  u_j'  \leq \pi' - a_{ij}', \; \forall a_{ij} \neq 0 \,, \\
                    &   u_j' -  u_i' \leq a_{ij}' - \psi', \; \forall a_{ij} \neq 0 \,, \\
  \text{variables}  &   \pi', \psi', u' \, .
  \end{array}\]

where \(k'\) denotes \(\log( | k | )\) and
\(x = (\pi', \psi' )^{ \mathrm{ T } }\).

\end{frame}

\begin{frame}[fragile]

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ con(G, e, x):}
\NormalTok{    u, v }\OperatorTok{=}\NormalTok{ e}
    \ControlFlowTok{if}\NormalTok{ u }\OperatorTok{<}\NormalTok{ v: }\ControlFlowTok{return}\NormalTok{ x[}\DecValTok{0}\NormalTok{] }\OperatorTok{-}\NormalTok{ G[u][v][}\StringTok{'cost'}\NormalTok{]}
    \ControlFlowTok{else}\NormalTok{: }\ControlFlowTok{return}\NormalTok{ G[u][v][}\StringTok{'cost'}\NormalTok{] }\OperatorTok{-}\NormalTok{ x[}\DecValTok{1}\NormalTok{]}

\KeywordTok{def}\NormalTok{ pcon(G, e, x):}
\NormalTok{    u, v }\OperatorTok{=}\NormalTok{ e}
    \ControlFlowTok{if}\NormalTok{ u }\OperatorTok{<}\NormalTok{ v: }\ControlFlowTok{return}\NormalTok{ np.array([}\FloatTok{1.}\NormalTok{, }\FloatTok{0.}\NormalTok{])}
    \ControlFlowTok{else}\NormalTok{: }\ControlFlowTok{return}\NormalTok{ np.array([}\FloatTok{0.}\NormalTok{, }\FloatTok{-1.}\NormalTok{])}

\KeywordTok{class}\NormalTok{ optscaling_oracle:}
    \KeywordTok{def} \FunctionTok{__init__}\NormalTok{(}\VariableTok{self}\NormalTok{, G):}
        \VariableTok{self}\NormalTok{.network }\OperatorTok{=}\NormalTok{ network_oracle(G, con, pcon)}

    \KeywordTok{def} \FunctionTok{__call__}\NormalTok{(}\VariableTok{self}\NormalTok{, x, t):}
\NormalTok{        cut, feasible }\OperatorTok{=} \VariableTok{self}\NormalTok{.network(x)}
        \ControlFlowTok{if} \KeywordTok{not}\NormalTok{ feasible: }\ControlFlowTok{return}\NormalTok{ cut, t}
\NormalTok{        s }\OperatorTok{=}\NormalTok{ x[}\DecValTok{0}\NormalTok{] }\OperatorTok{-}\NormalTok{ x[}\DecValTok{1}\NormalTok{]}
\NormalTok{        fj }\OperatorTok{=}\NormalTok{ s }\OperatorTok{-}\NormalTok{ t}
        \ControlFlowTok{if}\NormalTok{ fj }\OperatorTok{<} \FloatTok{0.}\NormalTok{:}
\NormalTok{            t }\OperatorTok{=}\NormalTok{ s}
\NormalTok{            fj }\OperatorTok{=} \FloatTok{0.}
        \ControlFlowTok{return}\NormalTok{ (np.array([}\FloatTok{1.}\NormalTok{, }\FloatTok{-1.}\NormalTok{]), fj), t}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Example: clock period \& yield-driven co-optimization}
\protect\hypertarget{sec:example-clock-period-yield-driven-co-optimization}{}

\[\begin{array}{cll}
   \text{minimize} &T_{CP} - w_{\beta}\beta \\
   \text{subject to} & u_i - u_j \le T_{CP} + F_{ij}^{-1}(1-\beta), & \forall (i,j) \in E_s \,,\\
                     & u_j - u_i \le F_{ij}^{-1}(1-\beta), & \forall (j,i) \in E_h \,, \\
                     & T_{CP} \ge 0, \, 0 \le \beta \le 1 \, , \\
    \text{variables} &T_{CP},\beta, u.
   \end{array}\]

\begin{itemize}
\tightlist
\item
  Note that \(F_{ij}^{-1}(x)\) is not concave in general in \([0,1]\).
\item
  Fortunately, we are most likely interested in optimizing circuits for
  high yield rather than the low one in practice.
\item
  Therefore, by imposing an additional constraint to \(\beta\), say
  \(\beta \geq 0.8\), the problem becomes convex.
\end{itemize}

\end{frame}

\begin{frame}{Inverse CDF}
\protect\hypertarget{sec:inverse-cdf}{}

\begin{figure}
\centering
\includegraphics{ellipsoid.files/Fig2-b-invcdf.pdf}
\caption{img}
\end{figure}

\end{frame}

\hypertarget{sec:matrix-inequalities}{%
\section{Matrix Inequalities}\label{sec:matrix-inequalities}}

\begin{frame}{Problems With Matrix Inequalities}
\protect\hypertarget{sec:problems-with-matrix-inequalities}{}

Consider the following problem:

\[\begin{array}{ll}
    \text{minimize}    & f_0(x), \\
    \text{subject to}  & F(x) \succeq 0,
\end{array}\]

\begin{itemize}
\tightlist
\item
  \(F(x)\): a matrix-valued function
\item
  \(A \succeq 0\) denotes \(A\) is positive semidefinite.
\end{itemize}

\end{frame}

\begin{frame}{Problems With Matrix Inequalities}
\protect\hypertarget{sec:problems-with-matrix-inequalities-1}{}

\begin{itemize}
\tightlist
\item
  Recall that a matrix \(A\) is positive semidefinite if and only if
  \(v^\mathsf{T} A v \ge 0\) for all \(v \in \mathbb{R}^N\).
\item
  The problem can be transformed into: \[\begin{array}{ll}
            \text{minimize}      & f_0(x), \\
            \text{subject to}    & v^\mathsf{T} F(x) v \ge 0, \; \forall v \in \mathbb{R}^N
    \end{array}\]
\item
  Consider \(v^\mathsf{T} F(x) v\) is concave for all \(v \in \mathbb{R}^N\)
  w.r.t. \(x\), then the above problem is a convex programming.
\item
  Reduce to \emph{semidefinite programming} if \(f_0(x)\) and \(F(x)\)
  are linear, i.e., \(F(x) = F_0 + x_1 F_1 + \cdots + x_n F_n\)
\end{itemize}

\end{frame}

\begin{frame}{Oracle in Matrix Inequalities}
\protect\hypertarget{sec:oracle-in-matrix-inequalities}{}

The oracle only needs to:

\begin{itemize}
\tightlist
\item
  Perform a \emph{row-based} Cholesky factorization such that
  \(F(x_0) = R^\mathsf{T} R\).
\item
  Let \(A_{:p,:p}\) denotes a submatrix
  \(A(1:p, 1:p) \in \mathbb{R}^{p\times p}\).
\item
  If Cholesky factorization fails at row \(p\),

  \begin{itemize}
  \tightlist
  \item
    there exists a vector
    \(e_p = (0, 0, \cdots, 0, 1)^\mathsf{T} \in \mathbb{R}^p\), such that

    \begin{itemize}
    \tightlist
    \item
      \(v = R_{:p,:p}^{-1} e_p\), and
    \item
      \(v^\mathsf{T} F_{:p,:p}(x_0) v < 0\).
    \end{itemize}
  \item
    The cut \((g, h)\) =
    \((-v^\mathsf{T} \partial F_{:p,:p}(x_0) v, -v^\mathsf{T} F_{:p,:p}(x_0) v)\)
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}[fragile]

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ lmi_oracle:}
    \CommentTok{''' Oracle for LMI constraint F*x <= B '''}

    \KeywordTok{def} \FunctionTok{__init__}\NormalTok{(}\VariableTok{self}\NormalTok{, F, B):}
        \VariableTok{self}\NormalTok{.F }\OperatorTok{=}\NormalTok{ F}
        \VariableTok{self}\NormalTok{.F0 }\OperatorTok{=}\NormalTok{ B}
        \VariableTok{self}\NormalTok{.A }\OperatorTok{=}\NormalTok{ np.zeros(B.shape)}

    \KeywordTok{def} \FunctionTok{__call__}\NormalTok{(}\VariableTok{self}\NormalTok{, x):}
\NormalTok{        n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(x)}

        \KeywordTok{def}\NormalTok{ getA(i, j):}
            \VariableTok{self}\NormalTok{.A[i, j] }\OperatorTok{=} \VariableTok{self}\NormalTok{.F0[i, j]}
            \VariableTok{self}\NormalTok{.A[i, j] }\OperatorTok{-=} \BuiltInTok{sum}\NormalTok{(}\VariableTok{self}\NormalTok{.F[k][i, j] }\OperatorTok{*}\NormalTok{ x[k]}
                                \ControlFlowTok{for}\NormalTok{ k }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n))}
            \ControlFlowTok{return} \VariableTok{self}\NormalTok{.A[i, j]}

\NormalTok{        Q }\OperatorTok{=}\NormalTok{ chol_ext(getA, }\BuiltInTok{len}\NormalTok{(}\VariableTok{self}\NormalTok{.A))}
        \ControlFlowTok{if}\NormalTok{ Q.is_spd(): }\ControlFlowTok{return} \VariableTok{None}\NormalTok{, }\DecValTok{1}
\NormalTok{        v }\OperatorTok{=}\NormalTok{ Q.witness()}
\NormalTok{        p }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(v)}
\NormalTok{        g }\OperatorTok{=}\NormalTok{ np.array([v.dot(}\VariableTok{self}\NormalTok{.F[i][:p, :p].dot(v))}
                      \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n)])}
        \ControlFlowTok{return}\NormalTok{ (g, }\FloatTok{1.}\NormalTok{), }\DecValTok{0}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Example: Matrix Norm Minimization}
\protect\hypertarget{sec:example-matrix-norm-minimization}{}

\begin{itemize}
\tightlist
\item
  Let \(A(x) = A_0 + x_1 A_1 + \cdots + x_n A_n\)
\item
  Problem \(\min_x \| A(x) \|\) can be reformulated as
  \[\begin{array}{ll}
       \text{minimize}      & t, \\
       \text{subject to}    & \left(
   \begin{array}{cc}
    t\,I   & A(x) \\
    A^\mathsf{T}(x) & t\,I
   \end{array} \right) \succeq 0,
   \end{array}\]
\item
  Binary search on \(t\) can be used for this problem.
\end{itemize}

\end{frame}

\begin{frame}[fragile]

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ qmi_oracle:}
    \KeywordTok{def} \FunctionTok{__init__}\NormalTok{(}\VariableTok{self}\NormalTok{, F, F0):}
        \VariableTok{self}\NormalTok{.F }\OperatorTok{=}\NormalTok{ F}\OperatorTok{;} \VariableTok{self}\NormalTok{.F0 }\OperatorTok{=}\NormalTok{ F0}
        \VariableTok{self}\NormalTok{.Fx }\OperatorTok{=}\NormalTok{ np.zeros(F0.shape)}
        \VariableTok{self}\NormalTok{.A }\OperatorTok{=}\NormalTok{ np.zeros(F0.shape)}
        \VariableTok{self}\NormalTok{.t }\OperatorTok{=} \VariableTok{None}\OperatorTok{;} \VariableTok{self}\NormalTok{.count }\OperatorTok{=} \DecValTok{-1}

    \KeywordTok{def}\NormalTok{ update(}\VariableTok{self}\NormalTok{, t): }\VariableTok{self}\NormalTok{.t }\OperatorTok{=}\NormalTok{ t}

    \KeywordTok{def} \FunctionTok{__call__}\NormalTok{(}\VariableTok{self}\NormalTok{, x):}
        \VariableTok{self}\NormalTok{.count }\OperatorTok{=} \DecValTok{-1}\OperatorTok{;}\NormalTok{ nx }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(x)}

        \KeywordTok{def}\NormalTok{ getA(i, j):}
            \ControlFlowTok{if} \VariableTok{self}\NormalTok{.count }\OperatorTok{<}\NormalTok{ i:}
                \VariableTok{self}\NormalTok{.count }\OperatorTok{=}\NormalTok{ i}\OperatorTok{;} \VariableTok{self}\NormalTok{.Fx[i] }\OperatorTok{=} \VariableTok{self}\NormalTok{.F0[i]}
                \VariableTok{self}\NormalTok{.Fx[i] }\OperatorTok{-=} \BuiltInTok{sum}\NormalTok{(}\VariableTok{self}\NormalTok{.F[k][i] }\OperatorTok{*}\NormalTok{ x[k]}
                                  \ControlFlowTok{for}\NormalTok{ k }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(nx))}
            \VariableTok{self}\NormalTok{.A[i, j] }\OperatorTok{=} \OperatorTok{-}\VariableTok{self}\NormalTok{.Fx[i].dot(}\VariableTok{self}\NormalTok{.Fx[j])}
            \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{==}\NormalTok{ j: }\VariableTok{self}\NormalTok{.A[i, j] }\OperatorTok{+=} \VariableTok{self}\NormalTok{.t}
            \ControlFlowTok{return} \VariableTok{self}\NormalTok{.A[i, j]}

\NormalTok{        Q }\OperatorTok{=}\NormalTok{ chol_ext(getA, }\BuiltInTok{len}\NormalTok{(}\VariableTok{self}\NormalTok{.A))}
        \ControlFlowTok{if}\NormalTok{ Q.is_spd(): }\ControlFlowTok{return} \VariableTok{None}\NormalTok{, }\DecValTok{1}
\NormalTok{        v }\OperatorTok{=}\NormalTok{ Q.witness()}\OperatorTok{;}\NormalTok{ p }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(v)}
\NormalTok{        Av }\OperatorTok{=}\NormalTok{ v.dot(}\VariableTok{self}\NormalTok{.Fx[:p])}
\NormalTok{        g }\OperatorTok{=} \FloatTok{-2.}\OperatorTok{*}\NormalTok{np.array([v.dot(}\VariableTok{self}\NormalTok{.F[k][:p]).dot(Av)}
                          \ControlFlowTok{for}\NormalTok{ k }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(nx)])}
        \ControlFlowTok{return}\NormalTok{ (g, }\FloatTok{1.}\NormalTok{), }\DecValTok{0}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Example: Estimation of Correlation Function}
\protect\hypertarget{sec:example-estimation-of-correlation-function}{}

\[\begin{array}{ll}
   \min_{\kappa, p}   & \| \Omega(p) + \kappa I - Y \| \\
   \text{s. t.} & \Omega(p) \succcurlyeq 0,  \kappa \geq 0 \; .\\
 \end{array}\]

\begin{itemize}
\item
  Let \(\rho(h) = \sum_i^n p_i \Psi_i(h)\), where

  \begin{itemize}
  \tightlist
  \item
    \(p_i\)’s are the unknown coefficients to be fitted
  \item
    \(\Psi_i\)’s are a family of basis functions.
  \end{itemize}
\item
  The covariance matrix \(\Omega(p)\) can be recast as:

  \[\Omega(p) = p_1 F_1 + \cdots + p_n F_n\]

  where \(\{F_k\}_{i,j} =\Psi_k( \| s_j - s_i \|_2)\)
\end{itemize}

\end{frame}

\begin{frame}{Basic Ellipsoid Method}
\protect\hypertarget{sec:basic-ellipsoid-method}{}

\begin{itemize}
\tightlist
\item
  An ellipsoid \(\mathcal{E}(x_c, P)\) is specified as a set
  \[\{x \mid (x-x_c)P^{-1}(x-x_c) \leq 1 \},\] where \(x_c\) is the
  center of the ellipsoid.
\end{itemize}

\includegraphics{ellipsoid.files/ellipsoid.pdf}

\end{frame}

\begin{frame}[fragile]{Python code}
\protect\hypertarget{sec:python-code-3}{}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}

\KeywordTok{class}\NormalTok{ ell:}
    \KeywordTok{def} \FunctionTok{__init__}\NormalTok{(}\VariableTok{self}\NormalTok{, val, x):}
        \CommentTok{'''ell = \{ x | (x - xc)' * P^-1 * (x - xc) <= 1 \}'''}
\NormalTok{        n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(x)}
        \ControlFlowTok{if}\NormalTok{ np.isscalar(val):}
            \VariableTok{self}\NormalTok{.P }\OperatorTok{=}\NormalTok{ val }\OperatorTok{*}\NormalTok{ np.identity(n)}
        \ControlFlowTok{else}\NormalTok{:}
            \VariableTok{self}\NormalTok{.P }\OperatorTok{=}\NormalTok{ np.diag(val)}
        \VariableTok{self}\NormalTok{.xc }\OperatorTok{=}\NormalTok{ np.array(x)}
        \VariableTok{self}\NormalTok{.c1 }\OperatorTok{=} \BuiltInTok{float}\NormalTok{(n}\OperatorTok{*}\NormalTok{n)}\OperatorTok{/}\NormalTok{(n}\OperatorTok{*}\NormalTok{n}\FloatTok{-1.}\NormalTok{)}

    \KeywordTok{def}\NormalTok{ update_core(}\VariableTok{self}\NormalTok{, calc_ell, cut):...}
    \KeywordTok{def}\NormalTok{ calc_cc(}\VariableTok{self}\NormalTok{, g):...}
    \KeywordTok{def}\NormalTok{ calc_dc(}\VariableTok{self}\NormalTok{, cut):...}
    \KeywordTok{def}\NormalTok{ calc_ll(}\VariableTok{self}\NormalTok{, cut):...}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Updating the ellipsoid (deep-cut)}
\protect\hypertarget{sec:updating-the-ellipsoid-deep-cut}{}

\begin{itemize}
\tightlist
\item
  Calculation of minimum volume ellipsoid covering:
  \[\mathcal{E} \cap \{z \mid g^\mathsf{T} (z - x_c) + h \leq 0 \}\]
\item
  Let \(\tilde{g} = P\,g\), \(\tau = \sqrt{g^\mathsf{T}\tilde{g}}\),
  \(\alpha = h/\tau\).
\item
  If \(\alpha > 1\), intersection is empty.
\item
  If \(\alpha < -1/n\) (shallow cut), no smaller ellipsoid can be found.
\item
  Otherwise, \[x_c^+ = x_c - \frac{\rho}{\tau} \tilde{g}, \qquad
  P^+ = \delta\left(P - \frac{\sigma}{\tau^2} \tilde{g}\tilde{g}^\mathsf{T}\right)
   \] where
\end{itemize}

\[\rho = \frac{1+n\alpha}{n+1}, \qquad
  \sigma = \frac{2\rho}{1+\alpha}, \qquad
  \delta = \frac{n^2(1-\alpha^2)}{n^2 - 1} \]

\end{frame}

\begin{frame}{Updating the ellipsoid (cont’d)}
\protect\hypertarget{sec:updating-the-ellipsoid-contd}{}

\begin{itemize}
\tightlist
\item
  Even better, split \(P\) into two variables \(\kappa \cdot Q\)
\item
  Let \(\tilde{g} = Q \cdot g\), \(\tau = \sqrt{g^\mathsf{T}\tilde{g}}\),
  \(\tau' = \sqrt{\kappa} \tau\), \(\alpha = h/\tau'\).
  \[x_c^+ = x_c - \frac{\rho}{\tau'} \tilde{g}, \qquad
  Q^+ = Q - \frac{\sigma}{\tau^2} \tilde{g}\tilde{g}^\mathsf{T}, \qquad
  \kappa^+ =  \delta \kappa
   \]
\item
  Reduce \(n^2\) multiplications per iteration.
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Python code (updating)}
\protect\hypertarget{sec:python-code-updating}{}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ update_core(}\VariableTok{self}\NormalTok{, calc_ell, cut):}
\NormalTok{    g, beta }\OperatorTok{=}\NormalTok{ cut}
\NormalTok{    Qg }\OperatorTok{=} \VariableTok{self}\NormalTok{.Q.dot(g)}
\NormalTok{    tsq }\OperatorTok{=}\NormalTok{ g.dot(Qg)}
\NormalTok{    tau }\OperatorTok{=}\NormalTok{ np.sqrt(}\VariableTok{self}\NormalTok{.kappa }\OperatorTok{*}\NormalTok{ tsq)}
\NormalTok{    alpha }\OperatorTok{=}\NormalTok{ beta }\OperatorTok{/}\NormalTok{ tau}
\NormalTok{    status, rho, sigma, delta }\OperatorTok{=}\NormalTok{ calc_ell(alpha)}
    \ControlFlowTok{if}\NormalTok{ status }\OperatorTok{!=} \DecValTok{0}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ status, tau}
    \VariableTok{self}\NormalTok{._xc }\OperatorTok{-=}\NormalTok{ (}\VariableTok{self}\NormalTok{.kappa }\OperatorTok{*}\NormalTok{ rho }\OperatorTok{/}\NormalTok{ tau) }\OperatorTok{*}\NormalTok{ Qg}
\OperatorTok{*}   \VariableTok{self}\NormalTok{.Q }\OperatorTok{-=}\NormalTok{ np.outer((sigma }\OperatorTok{/}\NormalTok{ tsq) }\OperatorTok{*}\NormalTok{ Qg, Qg)}
\OperatorTok{*}   \VariableTok{self}\NormalTok{.kappa }\OperatorTok{*=}\NormalTok{ delta}
    \ControlFlowTok{return}\NormalTok{ status, tau}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}[fragile]{Python code (deep cut)}
\protect\hypertarget{sec:python-code-deep-cut}{}

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{def}\NormalTok{ calc_dc(}\VariableTok{self}\NormalTok{, alpha):}
        \CommentTok{'''deep cut'''}
        \ControlFlowTok{if}\NormalTok{ alpha }\OperatorTok{==} \FloatTok{0.}\NormalTok{: }
            \ControlFlowTok{return} \VariableTok{self}\NormalTok{.calc_cc()}
\NormalTok{        n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(}\VariableTok{self}\NormalTok{.xc)}
\NormalTok{        status, rho, sigma, delta }\OperatorTok{=} \DecValTok{0}\NormalTok{, }\FloatTok{0.}\NormalTok{, }\FloatTok{0.}\NormalTok{, }\FloatTok{0.}
        \ControlFlowTok{if}\NormalTok{ alpha }\OperatorTok{>} \FloatTok{1.}\NormalTok{:}
\NormalTok{            status }\OperatorTok{=} \DecValTok{1}  \CommentTok{# no sol'n}
        \ControlFlowTok{elif}\NormalTok{ n}\OperatorTok{*}\NormalTok{alpha }\OperatorTok{<} \FloatTok{-1.}\NormalTok{:}
\NormalTok{            status }\OperatorTok{=} \DecValTok{3}  \CommentTok{# no effect}
        \ControlFlowTok{else}\NormalTok{:}
\NormalTok{            rho }\OperatorTok{=}\NormalTok{ (}\FloatTok{1.}\OperatorTok{+}\NormalTok{n}\OperatorTok{*}\NormalTok{alpha)}\OperatorTok{/}\NormalTok{(n}\OperatorTok{+}\DecValTok{1}\NormalTok{)}
\NormalTok{            sigma }\OperatorTok{=} \FloatTok{2.}\OperatorTok{*}\NormalTok{rho}\OperatorTok{/}\NormalTok{(}\FloatTok{1.}\OperatorTok{+}\NormalTok{alpha)}
\NormalTok{            delta }\OperatorTok{=} \VariableTok{self}\NormalTok{.c1}\OperatorTok{*}\NormalTok{(}\FloatTok{1.}\OperatorTok{-}\NormalTok{alpha}\OperatorTok{*}\NormalTok{alpha)}
        \ControlFlowTok{return}\NormalTok{ status, rho, sigma, delta}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Parallel Cuts}
\protect\hypertarget{sec:parallel-cuts}{}

\begin{itemize}
\item
  Oracle returns a pair of cuts instead of just one.
\item
  The pair of cuts is given by \(g\) and \((h_1, h_2)\) such that:
  \[\begin{array}{l}
  g^\mathsf{T} (x - x_c) + h_1 \leq 0,  \\
  g^\mathsf{T} (x - x_c) + h_2 \geq 0,
  \end{array}\] for all \(x \in \mathcal{K}\).
\item
  Only linear inequality constraint can produce such parallel cut:
  \[ l \leq a^\mathsf{T} x + b \leq u, \qquad L \preceq F(x) \preceq U \]
\item
  Usually provide faster convergence.
\end{itemize}

\end{frame}

\begin{frame}{Parallel Cuts}
\protect\hypertarget{sec:parallel-cuts-1}{}

\includegraphics{ellipsoid.files/parallel_cut.pdf}

\end{frame}

\begin{frame}{Updating the ellipsoid}
\protect\hypertarget{sec:updating-the-ellipsoid}{}

\begin{itemize}
\item
  Let \(\tilde{g} = P\,g\), \(\tau = \sqrt{g^\mathsf{T}\tilde{g}}\),
  \(\alpha_1 = h_1/\tau\), \(\alpha_2 = h_2/\tau\).
\item
  If \(\alpha_2 > 1\), it reduces to deep-cut with
  \(\alpha = \alpha_1\).
\item
  If \(\alpha_1 > \alpha_2\), intersection is empty.
\item
  If \(\alpha_1 \alpha_2 < -1/n\), no smaller ellipsoid can be found.
  Otherwise, \[x_c^+ = x_c - \frac{\rho}{\tau'} \tilde{g}, \qquad
  Q^+ = Q - \frac{\sigma}{\tau^2} \tilde{g}\tilde{g}^\mathsf{T}, \qquad
  \kappa^+ =  \delta \kappa
   \]

  where \[\begin{array}{lll}
    \xi &=& \sqrt{4(1 - \alpha_1^2)(1 - \alpha_2^2) + n^2(\alpha_2^2 - \alpha_1^2)^2}, \\
    \sigma &=& \frac{1}{n+1}(n + \frac{2}{(\alpha_1 + \alpha_2)^2}(1 - \alpha_1\alpha_2 - \frac{\xi}{2})), \\
    \rho &=& \frac{1}{2}(\alpha_1 + \alpha_2) \sigma, \\
    \delta &=& \frac{n^2}{n^2-1} (1 - \frac{1}{2}(\alpha_1^2 + \alpha_2^2 - \frac{\xi}{n}))
   \end{array}\]
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Python code (parallel cut)}
\protect\hypertarget{sec:python-code-parallel-cut}{}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a0, a1 }\OperatorTok{=}\NormalTok{ alpha}
\ControlFlowTok{if}\NormalTok{ a1 }\OperatorTok{>=} \FloatTok{1.}\NormalTok{: }\ControlFlowTok{return} \VariableTok{self}\NormalTok{.calc_dc(a0)}
\NormalTok{n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(}\VariableTok{self}\NormalTok{.xc)}
\NormalTok{status, rho, sigma, delta }\OperatorTok{=} \DecValTok{0}\NormalTok{, }\FloatTok{0.}\NormalTok{, }\FloatTok{0.}\NormalTok{, }\FloatTok{0.}
\NormalTok{aprod }\OperatorTok{=}\NormalTok{ a0 }\OperatorTok{*}\NormalTok{ a1}
\ControlFlowTok{if}\NormalTok{ a0 }\OperatorTok{>}\NormalTok{ a1: }
\NormalTok{    status }\OperatorTok{=} \DecValTok{1} \CommentTok{# no sol'n}
\ControlFlowTok{elif}\NormalTok{ n}\OperatorTok{*}\NormalTok{aprod }\OperatorTok{<} \FloatTok{-1.}\NormalTok{: }
\NormalTok{    status }\OperatorTok{=} \DecValTok{3}  \CommentTok{# no effect}
\ControlFlowTok{else}\NormalTok{:}
\NormalTok{    asq }\OperatorTok{=}\NormalTok{ alpha }\OperatorTok{*}\NormalTok{ alpha}
\NormalTok{    asum }\OperatorTok{=}\NormalTok{ a0 }\OperatorTok{+}\NormalTok{ a1}
\NormalTok{    asqdiff }\OperatorTok{=}\NormalTok{ asq[}\DecValTok{1}\NormalTok{] }\OperatorTok{-}\NormalTok{ asq[}\DecValTok{0}\NormalTok{]}
\NormalTok{    xi }\OperatorTok{=}\NormalTok{ np.sqrt(}\FloatTok{4.}\OperatorTok{*}\NormalTok{(}\FloatTok{1.}\OperatorTok{-}\NormalTok{asq[}\DecValTok{0}\NormalTok{])}\OperatorTok{*}\NormalTok{(}\FloatTok{1.}\OperatorTok{-}\NormalTok{asq[}\DecValTok{1}\NormalTok{]) }\OperatorTok{+}\NormalTok{ n}\OperatorTok{*}\NormalTok{n}\OperatorTok{*}\NormalTok{asqdiff}\OperatorTok{*}\NormalTok{asqdiff)}
\NormalTok{    sigma }\OperatorTok{=}\NormalTok{ (n }\OperatorTok{+}\NormalTok{ (}\FloatTok{2.}\OperatorTok{*}\NormalTok{(}\FloatTok{1.} \OperatorTok{+}\NormalTok{ aprod }\OperatorTok{-}\NormalTok{ xi}\OperatorTok{/}\FloatTok{2.}\NormalTok{)}\OperatorTok{/}\NormalTok{(asum}\OperatorTok{*}\NormalTok{asum)))}\OperatorTok{/}\NormalTok{(n}\OperatorTok{+}\DecValTok{1}\NormalTok{)}
\NormalTok{    rho }\OperatorTok{=}\NormalTok{ asum }\OperatorTok{*}\NormalTok{ sigma}\OperatorTok{/}\FloatTok{2.}
\NormalTok{    delta }\OperatorTok{=} \VariableTok{self}\NormalTok{.c1}\OperatorTok{*}\NormalTok{(}\FloatTok{1.} \OperatorTok{-}\NormalTok{ (asq[}\DecValTok{0}\NormalTok{] }\OperatorTok{+}\NormalTok{ asq[}\DecValTok{1}\NormalTok{] }\OperatorTok{-}\NormalTok{ xi}\OperatorTok{/}\NormalTok{n)}\OperatorTok{/}\FloatTok{2.}\NormalTok{)        }
\ControlFlowTok{return}\NormalTok{ status, rho, sigma, delta}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Example: FIR filter design}
\protect\hypertarget{sec:example-fir-filter-design}{}

\begin{figure}
\centering
\includegraphics{ellipsoid.files/fir_strctr.pdf}
\caption{img}
\end{figure}

\begin{itemize}
\tightlist
\item
  The time response is: \[y[t] = \sum_{k=0}^{n-1}{h[k]u[t-k]}\]
\end{itemize}

\end{frame}

\begin{frame}{Example: FIR filter design (cont’d)}
\protect\hypertarget{sec:example-fir-filter-design-contd}{}

\begin{itemize}
\item
  The frequency response:
  \[H(\omega)~=~\sum_{m=0}^{n-1}{h(m)e^{-jm\omega}}\]
\item
  The magnitude constraints on frequency domain are expressed as

  \[L(\omega)~\leq~|H(\omega)|~\leq~U(\omega),~\forall~\omega\in(-\infty,+\infty)\]

  where \(L(\omega)\) and \(U(\omega)\) are the lower and upper
  (nonnegative) bounds at frequency \(\omega\) respectively.
\item
  The constraint is non-convex in general.
\end{itemize}

\end{frame}

\begin{frame}{Example: FIR filter design (cont’d)}
\protect\hypertarget{sec:example-fir-filter-design-contd-1}{}

\begin{itemize}
\tightlist
\item
  However, via \emph{spectral factorization}, it can transform into a
  convex one:
  \[L^2(\omega)~\leq~R(\omega)~\leq~U^2(\omega),~\forall~\omega\in(0,\pi)\]
  where

  \begin{itemize}
  \tightlist
  \item
    \(R(\omega)=\sum_{i=-1+n}^{n-1}{r(t)e^{-j{\omega}t}}=|H(\omega)|^2\)
  \item
    \(\mathbf{r}=(r(-n+1),r(-n+2),...,r(n-1))\) are the autocorrelation
    coefficients.
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{Example: FIR filter design (cont’d)}
\protect\hypertarget{sec:example-fir-filter-design-contd-2}{}

\begin{itemize}
\item
  \(\mathbf{r}\) can be determined by \(\mathbf{h}\):

  \[r(t)~=~\sum_{i=-n+1}^{n-1}{h(i)h(i+t)},~t\in\mathbf{Z}.\]

  where \(h(t)=0\) for \(t < 0\) or \(t > n-1\).
\item
  The whole problem can be formulated as:
\end{itemize}

\[\begin{array}{ll}
  \text{min}  & \gamma \\
  \text{s.t.} & L^2(\omega) \leq R(\omega) \leq U^2(\omega), \; \forall \omega \in [0,\pi]   \\
              & R(\omega) > 0, \forall \omega \in [0,\pi]
\end{array}\]

\end{frame}

\begin{frame}{Example: Maximum Likelihood estimation}
\protect\hypertarget{sec:example-maximum-likelihood-estimation}{}

\[\begin{array}{ll}
      \min_{\kappa, p}   &      \log \det (\Omega(p) + \kappa I) + \mathrm{Tr}((\Omega(p) + \kappa I)^{-1}Y) \\
      \text{s.t.} & \Omega(p) \succeq 0, \kappa \geq 0 \\
 \end{array}\]

Note: 1st term is concave, 2nd term is convex

\begin{itemize}
\tightlist
\item
  However, if there is enough samples such that \(Y\) is a positive
  definite matrix, then the function is convex within \([0, 2Y]\)
\end{itemize}

\end{frame}

\begin{frame}{Example: Maximum Likelihood estimation (cont’d)}
\protect\hypertarget{sec:example-maximum-likelihood-estimation-contd}{}

\begin{itemize}
\tightlist
\item
  Therefore, the following problem is convex:
\end{itemize}

\[\begin{array}{ll}
      \min_{\kappa, p}   &   \log \det V(p) + \mathrm{Tr}(V(p)^{-1}Y) \\
      \text{s.t.} & \Omega(p) + \kappa I = V(p) \\
                    & 0 \preceq V(p) \preceq 2Y, \kappa \geq 0
\end{array}\]

\end{frame}

\hypertarget{sec:discrete-optimization}{%
\section{Discrete Optimization}\label{sec:discrete-optimization}}

\begin{frame}{Why Discrete Convex Programming}
\protect\hypertarget{sec:why-discrete-convex-programming}{}

\begin{itemize}
\item
  Many engineering problems can be formulated as a convex/geometric
  programming, e.g.~digital circuit sizing
\item
  Yet in an ASIC design, often there is only a limited set of choices
  from the cell library. In other words, some design variables are
  discrete.
\item
  The discrete version can be formulated as a Mixed-Integer Convex
  programming (MICP) by mapping the design variables to integers.
\end{itemize}

\end{frame}

\begin{frame}{What’s Wrong w/ Existing Methods?}
\protect\hypertarget{sec:whats-wrong-w-existing-methods}{}

\begin{itemize}
\item
  Mostly based on relaxation.
\item
  Then use the relaxed solution as a lower bound and use the
  branch–and–bound method for the discrete optimal solution.

  \begin{itemize}
  \tightlist
  \item
    Note: the branch-and-bound method does not utilize the convexity of
    the problem.
  \end{itemize}
\item
  What if I can only evaluate constraints on discrete data? Workaround:
  convex fitting?
\end{itemize}

\end{frame}

\begin{frame}{Mixed-Integer Convex Programming}
\protect\hypertarget{sec:mixed-integer-convex-programming}{}

Consider: \[\begin{array}{ll}
        \text{minimize}      & f_0(x), \\
        \text{subject to}    & f_j(x) \leq 0, \; \forall j=1,2,\ldots \\
                             & x \in \mathbb{D} 
\end{array}\] where - \(f_0(x)\) and \(f_j(x)\) are “convex” - Some
design variables are discrete.

\end{frame}

\begin{frame}{Oracle Requirement}
\protect\hypertarget{sec:oracle-requirement}{}

\begin{itemize}
\item
  The oracle looks for the nearby discrete solution \(x_d\) of \(x_c\)
  with the cutting-plane:
  \[g^\mathsf{T} (x - x_d) + h \leq 0, h \geq 0, g \neq 0\]
\item
  Note: the cut may be a shallow cut.
\item
  Suggestion: use different cuts as possible for each iteration (
  e.g.~round-robin the evaluation of constraints)
\end{itemize}

\end{frame}

\begin{frame}{Example: FIR filter design}
\protect\hypertarget{sec:example-fir-filter-design-1}{}

\includegraphics[width=0.9\textwidth,height=\textheight]{ellipsoid.files/lowpass_ripple.pdf}

\end{frame}

\end{document}
