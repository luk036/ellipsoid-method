\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*}{xcolor}
%
\documentclass[10pt,ignorenonframetext,serif,onlymath]{beamer}
\setbeamertemplate{caption}[numbered]
\setbeamertemplate{caption label separator}{: }
\setbeamercolor{caption name}{fg=normal text.fg}
\beamertemplatenavigationsymbolsempty
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
            pdftitle={Cutting-plane Method and the Amazing Oracles},
            pdfauthor={Wai-Shing Luk},
            colorlinks=true,
            linkcolor=Maroon,
            citecolor=Blue,
            urlcolor=Blue,
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\newif\ifbibliography
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Prevent slide breaks in the middle of a paragraph:
\widowpenalties 1 10000
\raggedbottom
\setbeamertemplate{part page}{
\centering
\begin{beamercolorbox}[sep=16pt,center]{part title}
  \usebeamerfont{part title}\insertpart\par
\end{beamercolorbox}
}
\setbeamertemplate{section page}{
\centering
\begin{beamercolorbox}[sep=12pt,center]{part title}
  \usebeamerfont{section title}\insertsection\par
\end{beamercolorbox}
}
\setbeamertemplate{subsection page}{
\centering
\begin{beamercolorbox}[sep=8pt,center]{part title}
  \usebeamerfont{subsection title}\insertsubsection\par
\end{beamercolorbox}
}
\AtBeginPart{
  \frame{\partpage}
}
\AtBeginSection{
  \ifbibliography
  \else
    \frame{\sectionpage}
  \fi
}
\AtBeginSubsection{
  \frame{\subsectionpage}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\usetheme{default}
\usepackage{tikz,pgf,pgfplots}
\usetikzlibrary{arrows}
\definecolor{qqqqff}{rgb}{0.,0.,1.}
\newcommand{\columnsbegin}{\begin{columns}}
\newcommand{\columnsend}{\end{columns}}
\newcommand{\col}[1]{\column{#1}}
\pgfdeclareimage[height=0.5cm]{fudan-logo}{fudan-logo.jpg}
\logo{\pgfuseimage{fudan-logo}}

\title{Cutting-plane Method and the Amazing Oracles}
\author{Wai-Shing Luk}
\providecommand{\institute}[1]{}
\institute{Fudan University}
\date{\today}

\begin{document}
\frame{\titlepage}

\begin{frame}
\tableofcontents[hideallsubsections]
\end{frame}
\begin{frame}

\begin{quote}
When you have eliminated the impossible, whatever remains, however
improbable, must be the truth.
\end{quote}

\emph{Sir Arthur Conan Doyle, stated by Sherlock Holmes}

\end{frame}

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

\begin{frame}{Some History of Ellipsoid Method}
\protect\hypertarget{some-history-of-ellipsoid-method}{}

\begin{itemize}
\item
  Introduced by Shor and Yudin and Nemirovskii in 1976
\item
  Used to show that linear programming (LP) is polynomial-time solvable
  (Kachiyan 1979), settled the long-standing problem of determining the
  theoretically complexity of LP.
\item
  In practice, however, the simplex method runs much faster than the
  method, although its worst-case complexity is exponential.
\end{itemize}

\end{frame}

\begin{frame}{Common Perspective of Ellipsoid Method}
\protect\hypertarget{common-perspective-of-ellipsoid-method}{}

\begin{itemize}
\item
  It is commonly believed that it is inefficient in practice for
  large-scale problems.

  \begin{itemize}
  \item
    The convergent rate is slow, even with the use of deep cuts.
  \item
    Cannot exploit sparsity.
  \end{itemize}
\item
  Since then, it was supplanted by interior-point methods.
\item
  Only treated as a theoretical tool for proving the polynomial-time
  solvability of combinatorial optimization problems.
\end{itemize}

\end{frame}

\begin{frame}{But\ldots{}}
\protect\hypertarget{but}{}

\begin{itemize}
\item
  The ellipsoid method works very differently compared with the interior
  point method.
\item
  Only require a cutting-plane oracle. Can play nicely with other
  techniques.
\item
  The oracle can exploit sparsity.
\end{itemize}

\end{frame}

\begin{frame}{Consider Ellipsoid Method When\ldots{}}
\protect\hypertarget{consider-ellipsoid-method-when}{}

\begin{itemize}
\item
  The number of optimization variables is moderate, e.g.~ECO flow,
  analog circuit sizing, parametric problems
\item
  The number of constraints is large, or even infinite
\item
  Oracle can be implemented efficiently.
\end{itemize}

\end{frame}

\hypertarget{cutting-plane-method-revisited}{%
\section{Cutting-plane Method
Revisited}\label{cutting-plane-method-revisited}}

\begin{frame}{Basic Idea}
\protect\hypertarget{basic-idea}{}

\begin{columns}

\column{0.6\textwidth}

\begin{itemize}
\tightlist
\item
  Let \(\mathcal{K} \subseteq \mathbb{R}^n\) be a convex set.
\item
  Consider the feasibility problem:

  \begin{itemize}
  \tightlist
  \item
    Find a point \(x^* \in \mathbb{R}^n\) in \(\mathcal{K}\),
  \item
    or determine that \(\mathcal{K}\) is empty (i.e., no feasible sol’n)
  \end{itemize}
\end{itemize}

\column{0.4\textwidth}

\includegraphics{ellipsoid.files/region.pdf}

\end{columns}

\end{frame}

\begin{frame}{Separation Oracle}
\protect\hypertarget{separation-oracle}{}

\begin{columns}

\column{0.6\textwidth}

\begin{itemize}
\tightlist
\item
  When a separation oracle \(\Omega\) is \emph{queried} at \(x_0\), it
  either

  \begin{itemize}
  \tightlist
  \item
    asserts that \(x_0 \in \mathcal{K}\), or
  \item
    returns a separating hyperplane between \(x_0\) and \(\mathcal{K}\):
    \[g^\mathsf{T} (x - x_0) + h \leq 0, h \geq 0, g \neq 0, \;
          \forall x \in \mathcal{K}\]
  \end{itemize}
\end{itemize}

\column{0.4\textwidth}

\includegraphics{ellipsoid.files/cut.pdf}

\end{columns}

\end{frame}

\begin{frame}{Separation oracle (cont’d)}
\protect\hypertarget{separation-oracle-contd}{}

\begin{itemize}
\item
  \((g, h)\) called a \emph{cutting-plane}, or cut, since it eliminates
  the halfspace \(\{x \mid g^\mathsf{T} (x - x_0) + h > 0\}\) from our search.
\item
  If \(h=0\) (\(x_0\) is on boundary of halfspace that is cut),
  cutting-plane is called \emph{neutral cut}.
\item
  If \(h>0\) (\(x_0\) lies in interior of halfspace that is cut),
  cutting-plane is called \emph{deep cut}.
\end{itemize}

\end{frame}

\begin{frame}{Subgradient}
\protect\hypertarget{subgradient}{}

\begin{itemize}
\tightlist
\item
  \(\mathcal{K}\) is usually given by a set of inequalities
  \(f_j(x) \le 0\) or \(f_j(x) < 0\) for \(j = 1 \cdots m\), where
  \(f_j(x)\) is a convex function.
\item
  A vector \(g \equiv \partial f(x_0)\) is called a subgradient of a
  convex function \(f\) at \(x_0\) if
  \(f(z) \geq f(x_0) + g^\mathrm{T} (z - x_0)\).
\item
  Hence, the cut \((g, h)\) is given by \((\partial f(x_0), f(x_0))\)
\end{itemize}

Remarks:

\begin{itemize}
\tightlist
\item
  If \(f(x)\) is differentiable, we can simply take
  \(\partial f(x_0) = \nabla f(x_0)\)
\end{itemize}

\end{frame}

\begin{frame}{Key components of Cutting-plane method}
\protect\hypertarget{key-components-of-cutting-plane-method}{}

\begin{itemize}
\tightlist
\item
  Cutting plane oracle \(\Omega\)
\item
  A search space \(\mathcal{S}\) initially big enough to cover
  \(\mathcal{K}\), e.g.

  \begin{itemize}
  \tightlist
  \item
    Polyhedron \(\mathcal{P}\) = \(\{z \mid C z \preceq d \}\)
  \item
    Interval \(\mathcal{I}\) = \([l, u]\) (for one-dimensional problem)
  \item
    Ellipsoid \(\mathcal{E}\) =
    \(\{z \mid (z-x_c)P^{-1}(z-x_c) \leq 1 \}\)
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{Generic Cutting-plane method}
\protect\hypertarget{generic-cutting-plane-method}{}

\begin{itemize}
\tightlist
\item
  \textbf{Given} initial \(\mathcal{S}\) known to contain
  \(\mathcal{K}\).
\item
  \textbf{Repeat}

  \begin{enumerate}
  [1.]
  \tightlist
  \item
    Choose a point \(x_0\) in \(\mathcal{S}\)
  \item
    Query the cutting-plane oracle at \(x_0\)
  \item
    \textbf{If} \(x_0 \in \mathcal{K}\), quit
  \item
    \textbf{Else}, update \(\mathcal{S}\) to a smaller set that covers:
    \[\mathcal{S}^+ = \mathcal{S} \cap \{z \mid g^\mathsf{T} (z - x_0) + h \leq 0\}\]
  \item
    \textbf{If} \(\mathcal{S}^+ = \emptyset\) or it is small enough,
    quit.
  \end{enumerate}
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Corresponding Python code}
\protect\hypertarget{corresponding-python-code}{}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ cutting_plane_feas(evaluate, S, options}\OperatorTok{=}\NormalTok{Options()):}
\NormalTok{    feasible }\OperatorTok{=} \VariableTok{False}
\NormalTok{    status }\OperatorTok{=} \DecValTok{0}
    \ControlFlowTok{for}\NormalTok{ niter }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(options.max_it):}
\NormalTok{        cut, feasible }\OperatorTok{=}\NormalTok{ evaluate(S.xc)}
        \ControlFlowTok{if}\NormalTok{ feasible:  }\CommentTok{# feasible sol'n obtained}
            \ControlFlowTok{break}
\NormalTok{        status, tau }\OperatorTok{=}\NormalTok{ S.update(cut)}
        \ControlFlowTok{if}\NormalTok{ status }\OperatorTok{!=} \DecValTok{0}\NormalTok{:}
            \ControlFlowTok{break}
        \ControlFlowTok{if}\NormalTok{ tau }\OperatorTok{<}\NormalTok{ options.tol:}
\NormalTok{            status }\OperatorTok{=} \DecValTok{2}
            \ControlFlowTok{break}
    \ControlFlowTok{return}\NormalTok{ S.xc, niter}\OperatorTok{+}\DecValTok{1}\NormalTok{, feasible, status}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Convex Optimization Problem (I)}
\protect\hypertarget{convex-optimization-problem-i}{}

\[\begin{array}{ll}
    \text{minimize}     & f_0({\color{blue}x}), \\
    \text{subject to}   & x \in \mathcal{K}
\end{array}\]

\begin{itemize}
\item
  The optimization problem is treated as a feasibility problem with an
  additional constraint \(f_0({\color{blue}x}) < {\color{purple}t}\)
\item
  \(f_0({\color{blue}x})\) could be a convex function or a quasiconvex
  function.
\item
  \({\color{purple}t}\) is the best-so-far value of
  \(f_0({\color{blue}x})\).
\end{itemize}

\end{frame}

\begin{frame}{Convex Optimization Problem (II)}
\protect\hypertarget{convex-optimization-problem-ii}{}

\begin{itemize}
\item
  Problem can be reformulated as: \[\begin{array}{ll}
              \text{minimize}         & {\color{purple}t}, \\
              \text{subject to}   & \Phi({\color{blue}x}, {\color{purple}t}) < 0 \\
                                  & {\color{blue}x} \in \mathcal{K}
    \end{array}\] where \(\Phi({\color{blue}x}, {\color{purple}t}) < 0\)
  is the \({\color{purple}t}\)-sublevel set of \(f_0({\color{blue}x})\).
\item
  Note: \(\mathcal{K}_t \subseteq \mathcal{K}_u\) if and only if
  \(t \leq u\) (monotonicity)
\item
  One easy way to solve the optimization problem is to apply the binary
  search on \({\color{purple}t}\).
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Corresponding Python code}
\protect\hypertarget{corresponding-python-code-1}{}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ bsearch(evaluate, I, options}\OperatorTok{=}\NormalTok{Options()):}
    \CommentTok{# assume monotone}
\NormalTok{    feasible }\OperatorTok{=} \VariableTok{False}
\NormalTok{    l, u }\OperatorTok{=}\NormalTok{ I}
\NormalTok{    t }\OperatorTok{=}\NormalTok{ l }\OperatorTok{+}\NormalTok{ (u }\OperatorTok{-}\NormalTok{ l)}\OperatorTok{/}\DecValTok{2}
    \ControlFlowTok{for}\NormalTok{ niter }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(options.max_it):}
        \ControlFlowTok{if}\NormalTok{ evaluate(t):  }\CommentTok{# feasible sol'n obtained}
\NormalTok{            feasible }\OperatorTok{=} \VariableTok{True}
\NormalTok{            u }\OperatorTok{=}\NormalTok{ t}
        \ControlFlowTok{else}\NormalTok{:}
\NormalTok{            l }\OperatorTok{=}\NormalTok{ t}
\NormalTok{        tau }\OperatorTok{=}\NormalTok{ (u }\OperatorTok{-}\NormalTok{ l)}\OperatorTok{/}\DecValTok{2}
\NormalTok{        t }\OperatorTok{=}\NormalTok{ l }\OperatorTok{+}\NormalTok{ tau}
        \ControlFlowTok{if}\NormalTok{ tau }\OperatorTok{<}\NormalTok{ options.tol:}
            \ControlFlowTok{break}
    \ControlFlowTok{return}\NormalTok{ u, niter}\OperatorTok{+}\DecValTok{1}\NormalTok{, feasible}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}[fragile]

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ bsearch_adaptor:}
    \KeywordTok{def} \FunctionTok{__init__}\NormalTok{(}\VariableTok{self}\NormalTok{, P, E, options}\OperatorTok{=}\NormalTok{Options()):}
        \VariableTok{self}\NormalTok{.P }\OperatorTok{=}\NormalTok{ P}
        \VariableTok{self}\NormalTok{.E }\OperatorTok{=}\NormalTok{ E}
        \VariableTok{self}\NormalTok{.options }\OperatorTok{=}\NormalTok{ options}

    \AttributeTok{@property}
    \KeywordTok{def}\NormalTok{ x_best(}\VariableTok{self}\NormalTok{):}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.E.xc}

    \KeywordTok{def} \FunctionTok{__call__}\NormalTok{(}\VariableTok{self}\NormalTok{, t):}
\NormalTok{        E }\OperatorTok{=} \VariableTok{self}\NormalTok{.E.copy()}
        \VariableTok{self}\NormalTok{.P.update(t)}
\NormalTok{        x, _, feasible, _ }\OperatorTok{=}\NormalTok{ cutting_plane_feas(}
            \VariableTok{self}\NormalTok{.P, E, }\VariableTok{self}\NormalTok{.options)}
        \ControlFlowTok{if}\NormalTok{ feasible:}
            \VariableTok{self}\NormalTok{.E._xc }\OperatorTok{=}\NormalTok{ x.copy()}
            \ControlFlowTok{return} \VariableTok{True}
        \ControlFlowTok{return} \VariableTok{False}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Shrinking}
\protect\hypertarget{shrinking}{}

\begin{itemize}
\tightlist
\item
  Another possible way is, to update the best-so-far
  \({\color{purple}t}\) whenever a feasible solution \(x_0\) is found
  such that \(\Phi({\color{blue}x_0}, {\color{purple}t}) = 0\).
\item
  We assume that the oracle takes the responsibility for that.
\end{itemize}

\end{frame}

\begin{frame}{Generic Cutting-plane method (Optim)}
\protect\hypertarget{generic-cutting-plane-method-optim}{}

\begin{itemize}
\tightlist
\item
  \textbf{Given} initial \(\mathcal{S}\) known to contain
  \(\mathcal{K}_{\color{purple}t}\).
\item
  \textbf{Repeat}

  \begin{enumerate}
  [1.]
  \tightlist
  \item
    Choose a point \(x_0\) in \(\mathcal{S}\)
  \item
    Query the separation oracle at \(x_0\)
  \item
    \textbf{If} \(x_0 \in \mathcal{K}_{\color{purple}t}\), update
    \({\color{purple}t}\) such that
    \(\Phi({\color{blue}x_0}, {\color{purple}t}) = 0\).
  \item
    Update \(\mathcal{S}\) to a smaller set that covers:
    \[\mathcal{S}^+ = \mathcal{S} \cap \{z \mid g^\mathsf{T} (z - x_0) + h \leq 0\} \]
  \item
    \textbf{If} \(\mathcal{S}^+ = \emptyset\) or it is small enough,
    quit.
  \end{enumerate}
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Corresponding Python code}
\protect\hypertarget{corresponding-python-code-2}{}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ cutting_plane_dc(evaluate, S, t, options}\OperatorTok{=}\NormalTok{Options()):}
\NormalTok{    feasible }\OperatorTok{=} \VariableTok{False}  \CommentTok{# no sol'n}
\NormalTok{    x_best }\OperatorTok{=}\NormalTok{ S.xc}
    \ControlFlowTok{for}\NormalTok{ niter }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(options.max_it):}
\NormalTok{        cut, t1 }\OperatorTok{=}\NormalTok{ evaluate(S.xc, t)}
        \ControlFlowTok{if}\NormalTok{ t }\OperatorTok{!=}\NormalTok{ t1:  }\CommentTok{# best t obtained}
\NormalTok{            feasible }\OperatorTok{=} \VariableTok{True}
\NormalTok{            t }\OperatorTok{=}\NormalTok{ t1}
\NormalTok{            x_best }\OperatorTok{=}\NormalTok{ S.xc}
\NormalTok{        status, tau }\OperatorTok{=}\NormalTok{ S.update(cut)}
        \ControlFlowTok{if}\NormalTok{ status }\OperatorTok{==} \DecValTok{1}\NormalTok{:}
            \ControlFlowTok{break}
        \ControlFlowTok{if}\NormalTok{ tau }\OperatorTok{<}\NormalTok{ options.tol:}
\NormalTok{            status }\OperatorTok{=} \DecValTok{2}
            \ControlFlowTok{break}
    \ControlFlowTok{return}\NormalTok{ x_best, t, niter}\OperatorTok{+}\DecValTok{1}\NormalTok{, feasible, status}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Example: Profit Maximization Problem}
\protect\hypertarget{example-profit-maximization-problem}{}

\[\begin{array}{ll}
   \text{maximize} & p(A x_1^\alpha x_2^\beta) - v_1 x_1 - v_2 x_2 \\
   \text{subject to}& x_1 \le k.
\end{array}\]

\begin{itemize}
\tightlist
\item
  \(p(A x_1^\alpha x_2^\beta)\) : Cobb-Douglas production function
\item
  \(p\): the market price per unit
\item
  \(A\): the scale of production
\item
  \(\alpha, \beta\): the output elasticities
\item
  \(x\): input quantity
\item
  \(v\): output price
\item
  \(k\): a given constant that restricts the quantity of \(x_1\)
\end{itemize}

\end{frame}

\begin{frame}{Example: Profit maximization (cont’d)}
\protect\hypertarget{example-profit-maximization-contd}{}

\begin{itemize}
\tightlist
\item
  The formulation is not in the convex form.
\item
  Rewrite the problem in the following form: \[\begin{array}{ll}
    \text{maximize} & t \\
    \text{subject to} & t  + v_1 x_1  + v_2 x_2 < p A x_1^{\alpha} x_2^{\beta}\\
                  & x_1 \le k.
    \end{array}\]
\end{itemize}

\end{frame}

\begin{frame}{Profit maximization in Convex Form}
\protect\hypertarget{profit-maximization-in-convex-form}{}

\begin{itemize}
\item
  By taking the logarithm of each variable:

  \begin{itemize}
  \tightlist
  \item
    \({\color{blue}y}_1 = \log x_1\), \({\color{blue}y}_2 = \log x_2\).
  \end{itemize}
\item
  We have the problem in a convex form:
\end{itemize}

\[\begin{array}{ll}
    \text{max}  & {\color{purple}t} \\
    \text{s.t.} & \log({\color{purple}t} + v_1 e^{{\color{blue}y}_1} + v_2 e^{{\color{blue}y}_2}) - (\alpha {\color{blue}y}_1 + \beta {\color{blue}y}_2) < \log(pA) \\
                & {\color{blue}y}_1 \le \log k.
\end{array}\]

\end{frame}

\begin{frame}[fragile,allowframebreaks]{Python code (Profit oracle)}
\protect\hypertarget{python-code-profit-oracle}{}

\scriptsize

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ profit_oracle:}
    \KeywordTok{def} \FunctionTok{__init__}\NormalTok{(}\VariableTok{self}\NormalTok{, params, a, v):}
\NormalTok{        p, A, k }\OperatorTok{=}\NormalTok{ params}
        \VariableTok{self}\NormalTok{.log_pA }\OperatorTok{=}\NormalTok{ np.log(p }\OperatorTok{*}\NormalTok{ A)}
        \VariableTok{self}\NormalTok{.log_k }\OperatorTok{=}\NormalTok{ np.log(k)}
        \VariableTok{self}\NormalTok{.v }\OperatorTok{=}\NormalTok{ v}\OperatorTok{;} \VariableTok{self}\NormalTok{.a }\OperatorTok{=}\NormalTok{ a}

    \KeywordTok{def} \FunctionTok{__call__}\NormalTok{(}\VariableTok{self}\NormalTok{, y, t):}
\NormalTok{        fj }\OperatorTok{=}\NormalTok{ y[}\DecValTok{0}\NormalTok{] }\OperatorTok{-} \VariableTok{self}\NormalTok{.log_k  }\CommentTok{# constraint}
        \ControlFlowTok{if}\NormalTok{ fj }\OperatorTok{>} \FloatTok{0.}\NormalTok{:}
\NormalTok{            g }\OperatorTok{=}\NormalTok{ np.array([}\FloatTok{1.}\NormalTok{, }\FloatTok{0.}\NormalTok{])}
            \ControlFlowTok{return}\NormalTok{ (g, fj), t}
\NormalTok{        log_Cobb }\OperatorTok{=} \VariableTok{self}\NormalTok{.log_pA }\OperatorTok{+}\NormalTok{ np.dot(}\VariableTok{self}\NormalTok{.a, y)}
\NormalTok{        x }\OperatorTok{=}\NormalTok{ np.exp(y)}
\NormalTok{        vx }\OperatorTok{=}\NormalTok{ np.dot(}\VariableTok{self}\NormalTok{.v, x)}
\NormalTok{        te }\OperatorTok{=}\NormalTok{ t }\OperatorTok{+}\NormalTok{ vx}
\NormalTok{        fj }\OperatorTok{=}\NormalTok{ np.log(te) }\OperatorTok{-}\NormalTok{ log_Cobb}
        \ControlFlowTok{if}\NormalTok{ fj }\OperatorTok{<} \FloatTok{0.}\NormalTok{:}
\NormalTok{            te }\OperatorTok{=}\NormalTok{ np.exp(log_Cobb)}
\NormalTok{            t }\OperatorTok{=}\NormalTok{ te }\OperatorTok{-}\NormalTok{ vx}\OperatorTok{;}\NormalTok{ fj }\OperatorTok{=} \FloatTok{0.}
\NormalTok{        g }\OperatorTok{=}\NormalTok{ (}\VariableTok{self}\NormalTok{.v }\OperatorTok{*}\NormalTok{ x) }\OperatorTok{/}\NormalTok{ te }\OperatorTok{-} \VariableTok{self}\NormalTok{.a}
        \ControlFlowTok{return}\NormalTok{ (g, fj), t}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}[fragile,allowframebreaks]{Python code (Main program)}
\protect\hypertarget{python-code-main-program}{}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{from}\NormalTok{ profit_oracle }\ImportTok{import} \OperatorTok{*}
\ImportTok{from}\NormalTok{ cutting_plane }\ImportTok{import} \OperatorTok{*}
\ImportTok{from}\NormalTok{ ell }\ImportTok{import} \OperatorTok{*}

\NormalTok{p, A, k }\OperatorTok{=} \FloatTok{20.0}\NormalTok{, }\FloatTok{40.0}\NormalTok{, }\FloatTok{30.5}
\NormalTok{params }\OperatorTok{=}\NormalTok{ p, A, k}
\NormalTok{alpha, beta }\OperatorTok{=} \FloatTok{0.1}\NormalTok{, }\FloatTok{0.4}
\NormalTok{v1, v2 }\OperatorTok{=} \FloatTok{10.0}\NormalTok{, }\FloatTok{35.0}
\NormalTok{y0 }\OperatorTok{=}\NormalTok{ np.array([}\FloatTok{0.0}\NormalTok{, }\FloatTok{0.0}\NormalTok{])  }\CommentTok{# initial x0}
\NormalTok{E }\OperatorTok{=}\NormalTok{ ell(}\DecValTok{200}\NormalTok{, y0)}
\NormalTok{P }\OperatorTok{=}\NormalTok{ profit_oracle(params, alpha, beta, v1, v2)}
\NormalTok{yb1, fb, }\BuiltInTok{iter}\NormalTok{, feasible, status }\OperatorTok{=} \OperatorTok{\textbackslash{}}
\NormalTok{    cutting_plane_dc(P, E, }\FloatTok{0.0}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(fb, }\BuiltInTok{iter}\NormalTok{, feasible, status)}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Area of Applications}
\protect\hypertarget{area-of-applications}{}

\begin{itemize}
\tightlist
\item
  Robust convex optimization

  \begin{itemize}
  \tightlist
  \item
    oracle technique: affine arithmetic
  \end{itemize}
\item
  Parametric network potential problem

  \begin{itemize}
  \tightlist
  \item
    oracle technique: negative cycle detection
  \end{itemize}
\item
  Semidefinite programming

  \begin{itemize}
  \tightlist
  \item
    oracle technique: Cholesky factorization
  \end{itemize}
\end{itemize}

\end{frame}

\hypertarget{robust-convex-optimization}{%
\section{Robust Convex Optimization}\label{robust-convex-optimization}}

\begin{frame}{Robust Optimization Formulation}
\protect\hypertarget{robust-optimization-formulation}{}

\begin{itemize}
\item
  Consider: \[\begin{array}{ll}
      \text{minimize}   & \sup_{q \in \mathbb Q} f_0({\color{blue}x},q) \\
      \text{subject to} & f_j({\color{blue}x},q) \leq 0, \;
       \forall q \in {\mathbb Q}, \; j = 1,2,\cdots,m,
    \end{array}\] where \(q\) represents a set of varying parameters.
\item
  The problem can be reformulated as: \[\begin{array}{ll}
      \text{minimize}   & {\color{purple}t} \\
      \text{subject to} & f_0({\color{blue}x},q) < {\color{purple}t}  \\
      & f_j({\color{blue}x},q) \leq 0, \;
       \forall q \in {\mathbb Q}, \; j = 1,2,\cdots,m,
    \end{array}\]
\end{itemize}

\end{frame}

\begin{frame}{Oracle in Robust Optimization Formulation}
\protect\hypertarget{oracle-in-robust-optimization-formulation}{}

\begin{itemize}
\tightlist
\item
  The oracle only needs to determine:

  \begin{itemize}
  \tightlist
  \item
    If \(f_j({\color{blue}x_0}, q) > 0\) for some \(j\) and \(q = q_0\),
    then

    \begin{itemize}
    \tightlist
    \item
      the cut \((g, h)\) =
      \((\partial f_j({\color{blue}x_0}, q_0), f_j({\color{blue}x_0}, q_0))\)
    \end{itemize}
  \item
    If \(f_0({\color{blue}x_0}, q) \geq {\color{purple}t}\) for some
    \(q = q_0\), then

    \begin{itemize}
    \tightlist
    \item
      the cut \((g, h)\) =
      \((\partial f_0({\color{blue}x_0}, q_0), f_0({\color{blue}x_0}, q_0) - {\color{purple}t})\)
    \end{itemize}
  \item
    Otherwise, \(x_0\) is feasible, then

    \begin{itemize}
    \tightlist
    \item
      Let
      \(q_{\max} = \text{argmax}_{q \in \mathbb Q} f_0({\color{blue}x_0}, q)\).
    \item
      \({\color{purple}t} := f_0({\color{blue}x_0}, q_{\max})\).
    \item
      The cut \((g, h)\) =
      \((\partial f_0({\color{blue}x_0}, q_{\max}), 0)\)
    \end{itemize}
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{Example: Profit Maximization Problem (convex)}
\protect\hypertarget{example-profit-maximization-problem-convex}{}

\[\begin{array}{ll}
\text{max}  & {\color{purple}t} \\
\text{s.t.} & \log({\color{purple}t} + \hat{v}_1 e^{{\color{blue}y}_1} + \hat{v}_2 e^{{\color{blue}y}_2}) - (\hat{\alpha} {\color{blue}y}_1 + \hat{\beta} {\color{blue}y}_2) \le \log(\hat{p}\,A)  \\
                  & {\color{blue}y}_1 \le \log \hat{k} ,
\end{array}\]

\begin{itemize}
\tightlist
\item
  Now assume that:

  \begin{itemize}
  \tightlist
  \item
    \(\hat{\alpha}\) and \(\hat{\beta}\) vary \(\bar{\alpha} \pm e_1\)
    and \(\bar{\beta} \pm e_2\) respectively.
  \item
    \(\hat{p}\), \(\hat{k}\), \(\hat{v}_1\), and \(\hat{v}_2\) all vary
    \(\pm e_3\).
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{Example: Profit Maximization Problem (oracle)}
\protect\hypertarget{example-profit-maximization-problem-oracle}{}

By detail analysis, the worst case happens when:

\begin{itemize}
\tightlist
\item
  \(p = \bar{p} + e_3\), \(k = \bar{k} + e_3\)
\item
  \(v_1 = \bar{v}_1 - e_3\), \(v_2 = \bar{v}_2 - e_3\),
\item
  if \({\color{blue}y}_1 > 0\), \(\alpha = \bar{\alpha} - e_1\), else
  \(\alpha = \bar{\alpha} + e_1\)
\item
  if \({\color{blue}y}_2 > 0\), \(\beta = \bar{\beta} - e_2\), else
  \(\beta = \bar{\beta} + e_2\)
\end{itemize}

\begin{quote}
\textbf{Remark}: for more complicated problems, affine arithmetic could
be used.
\end{quote}

\end{frame}

\begin{frame}[fragile]{\texttt{profit\_rb\_oracle}}
\protect\hypertarget{profit_rb_oracle}{}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ profit_rb_oracle:}
    \KeywordTok{def} \FunctionTok{__init__}\NormalTok{(}\VariableTok{self}\NormalTok{, params, a, v, vparams):}
\NormalTok{        ui, e1, e2, e3 }\OperatorTok{=}\NormalTok{ vparams}
        \VariableTok{self}\NormalTok{.uie }\OperatorTok{=}\NormalTok{ [ui }\OperatorTok{*}\NormalTok{ e1, ui }\OperatorTok{*}\NormalTok{ e2]}
        \VariableTok{self}\NormalTok{.a }\OperatorTok{=}\NormalTok{ a}\OperatorTok{;}\NormalTok{ p, A, k }\OperatorTok{=}\NormalTok{ params}
\NormalTok{        p }\OperatorTok{-=}\NormalTok{ ui }\OperatorTok{*}\NormalTok{ e3}\OperatorTok{;}\NormalTok{ k }\OperatorTok{-=}\NormalTok{ ui }\OperatorTok{*}\NormalTok{ e3}
\NormalTok{        v_rb }\OperatorTok{=}\NormalTok{ v.copy()}
\NormalTok{        v_rb }\OperatorTok{+=}\NormalTok{ ui }\OperatorTok{*}\NormalTok{ e3}
        \VariableTok{self}\NormalTok{.P }\OperatorTok{=}\NormalTok{ profit_oracle((p, A, k), a, v_rb)}

    \KeywordTok{def} \FunctionTok{__call__}\NormalTok{(}\VariableTok{self}\NormalTok{, y, t):}
\NormalTok{        a_rb }\OperatorTok{=} \VariableTok{self}\NormalTok{.a.copy()}
        \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ [}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{]:}
\NormalTok{            a_rb[i] }\OperatorTok{+=} \VariableTok{self}\NormalTok{.uie[i] }\OperatorTok{*}\NormalTok{ (}\OperatorTok{+}\FloatTok{1.}
                        \ControlFlowTok{if}\NormalTok{ y[i] }\OperatorTok{<=} \FloatTok{0.} \ControlFlowTok{else} \FloatTok{-1.}\NormalTok{)}
        \VariableTok{self}\NormalTok{.P.a }\OperatorTok{=}\NormalTok{ a_rb}
        \ControlFlowTok{return} \VariableTok{self}\NormalTok{.P(y, t)}
\end{Highlighting}
\end{Shaded}

\end{frame}

\hypertarget{parametric-network-potential-problem}{%
\section{Parametric Network Potential
Problem}\label{parametric-network-potential-problem}}

\begin{frame}{Parametric Network Potential Problem}
\protect\hypertarget{parametric-network-potential-problem-1}{}

Given a network represented by a directed graph \(G = (V, E)\).

Consider:

\[\begin{array}{ll}
    \text{minimize} & {\color{purple}t} \\
    \text{subject to} & {\color{red}u_i} - {\color{red}u_j} \le h_{ij}({\color{blue}x}, {\color{blue}t}), \; \forall (i, j) \in E ,\\
    \text{variables} &{\color{blue}x}, {\color{red}u} ,
   \end{array}\]

\begin{itemize}
\item
  \(h_{ij}({\color{blue}x}, {\color{blue}t})\) is the weight function of
  edge \((i,j)\),
\item
  Assume: network is large but the number of parameters is small.
\end{itemize}

\end{frame}

\begin{frame}{Network Potential Problem (cont’d)}
\protect\hypertarget{network-potential-problem-contd}{}

Given \(x\) and \(t\), the problem has a feasible solution if and only
if \(G\) contains no negative cycle. Let \(\mathcal{C}\) be a set of all
cycles of \(G\).

\[\begin{array}{ll}
    \text{minimize} & {\color{purple}t} \\
    \text{subject to} & W_k({\color{blue}x}, {\color{purple}t}) \ge 0, \forall C_k \in C ,\\
       \text{variables} & x
   \end{array}\]

\begin{itemize}
\item
  \(C_k\) is a cycle of \(G\)
\item
  \(W_k({\color{blue}x}, {\color{purple}t}) = \sum_{ (i,j)\in C_k} h_{ij}({\color{blue}x}, {\color{purple}t})\).
\end{itemize}

\end{frame}

\begin{frame}{Oracle in Network Potential Problem}
\protect\hypertarget{oracle-in-network-potential-problem}{}

\begin{itemize}
\tightlist
\item
  The oracle only needs to determine:

  \begin{itemize}
  \tightlist
  \item
    If there exists a negative cycle \(C_k\) under \(x_0\), then

    \begin{itemize}
    \tightlist
    \item
      the cut \((g, h)\) = \((-\partial W_k(x_0), -W_k(x_0))\)
    \end{itemize}
  \item
    If \(f_0(x_0) \geq {\color{purple}t}\), then

    \begin{itemize}
    \tightlist
    \item
      the cut \((g, h)\) =
      \((\partial f_0(x_0), f_0(x_0) - {\color{purple}t})\)
    \end{itemize}
  \item
    Otherwise, \(x_0\) is feasible, then

    \begin{itemize}
    \tightlist
    \item
      \({\color{purple}t} := f_0(x_0)\).
    \item
      The cut \((g, h)\) = \((\partial f_0(x_0), 0)\)
    \end{itemize}
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Python Code}
\protect\hypertarget{python-code}{}

\scriptsize

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ network_oracle:}
    \KeywordTok{def} \FunctionTok{__init__}\NormalTok{(}\VariableTok{self}\NormalTok{, G, f, p):}
        \VariableTok{self}\NormalTok{.G }\OperatorTok{=}\NormalTok{ G}
        \VariableTok{self}\NormalTok{.f }\OperatorTok{=}\NormalTok{ f}
        \VariableTok{self}\NormalTok{.p }\OperatorTok{=}\NormalTok{ p  }\CommentTok{# partial derivative of f w.r.t x}
        \VariableTok{self}\NormalTok{.S }\OperatorTok{=}\NormalTok{ negCycleFinder(G)}

    \KeywordTok{def} \FunctionTok{__call__}\NormalTok{(}\VariableTok{self}\NormalTok{, x):}
        \KeywordTok{def}\NormalTok{ get_weight(G, e):}
            \ControlFlowTok{return} \VariableTok{self}\NormalTok{.f(G, e, x)}

        \VariableTok{self}\NormalTok{.S.get_weight }\OperatorTok{=}\NormalTok{ get_weight}
\NormalTok{        C }\OperatorTok{=} \VariableTok{self}\NormalTok{.S.find_neg_cycle()}
        \ControlFlowTok{if}\NormalTok{ C }\KeywordTok{is} \VariableTok{None}\NormalTok{:}
            \ControlFlowTok{return} \VariableTok{None}\NormalTok{, }\DecValTok{1}
\NormalTok{        f }\OperatorTok{=} \OperatorTok{-}\BuiltInTok{sum}\NormalTok{(}\VariableTok{self}\NormalTok{.f(}\VariableTok{self}\NormalTok{.G, e, x) }\ControlFlowTok{for}\NormalTok{ e }\KeywordTok{in}\NormalTok{ C)}
\NormalTok{        g }\OperatorTok{=} \OperatorTok{-}\BuiltInTok{sum}\NormalTok{(}\VariableTok{self}\NormalTok{.p(}\VariableTok{self}\NormalTok{.G, e, x) }\ControlFlowTok{for}\NormalTok{ e }\KeywordTok{in}\NormalTok{ C)}
        \ControlFlowTok{return}\NormalTok{ (g, f), }\DecValTok{0}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Example: Optimal Matrix Scaling}
\protect\hypertarget{example-optimal-matrix-scaling}{}

\begin{itemize}
\item
  Given a sparse matrix \(A = [a_{ij}] \in \mathbb{R}^{N\times N}\).
\item
  Find another matrix \(B = U A U^{-1}\) where \(U\) is a nonnegative
  diagonal matrix, such that the ratio of any two elements of \(B\) in
  absolute value is as close to 1 as possible.
\item
  Let \(U = \mathrm{diag}([u_1, u_2, \ldots, u_N])\). Under the
  min-max-ratio criterion, the problem can be formulated as:
\end{itemize}

\[\begin{array}{ll}
  \text{minimize}   &   \pi/\psi  \\
  \text{subject to} &   \psi \leq u_i |a_{ij}| u_j^{-1} \leq \pi, \; \forall a_{ij} \neq 0 , \\
                    &   \pi, \, \psi, u, \text{positive} \\
  \text{variables}  &   \pi, \psi, u \, .
  \end{array}\]

\end{frame}

\begin{frame}{Optimal Matrix Scaling (cont’d)}
\protect\hypertarget{optimal-matrix-scaling-contd}{}

By taking the logarithms of variables, the above problem can be
transformed into:

\[\begin{array}{ll}
  \text{minimize}   &   {\color{purple}t} \\
  \text{subject to} &   {\color{blue}\pi'} - {\color{blue}\psi'} \leq {\color{purple}t} \\
                    &   {\color{red}u_i'} - {\color{red}u_j'}  \leq {\color{blue}\pi'} - a_{ij}', \; \forall a_{ij} \neq 0 \,, \\
                    &   {\color{red}u_j'} - {\color{red}u_i'} \leq a_{ij}' - {\color{blue}\psi'}, \; \forall a_{ij} \neq 0 \,, \\
  \text{variables}  &   {\color{blue}\pi'}, {\color{blue}\psi'}, {\color{red}u'} \, .
  \end{array}\]

where \(k'\) denotes \(\log( | k | )\) and
\(x = ({\color{blue}\pi'}, {\color{blue}\psi'} )^\mathsf{T}\).

\end{frame}

\begin{frame}[fragile]{Corresponding Python Code}
\protect\hypertarget{corresponding-python-code-3}{}

\scriptsize

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ con(G, e, x):}
\NormalTok{    u, v }\OperatorTok{=}\NormalTok{ e}
    \ControlFlowTok{if}\NormalTok{ index[u] }\OperatorTok{<}\NormalTok{ index[v]: }\ControlFlowTok{return}\NormalTok{ x[}\DecValTok{0}\NormalTok{] }\OperatorTok{-}\NormalTok{ G[u][v][}\StringTok{'cost'}\NormalTok{]}
    \ControlFlowTok{else}\NormalTok{: }\ControlFlowTok{return}\NormalTok{ G[u][v][}\StringTok{'cost'}\NormalTok{] }\OperatorTok{-}\NormalTok{ x[}\DecValTok{1}\NormalTok{]}

\KeywordTok{def}\NormalTok{ pcon(G, e, x):}
\NormalTok{    u, v }\OperatorTok{=}\NormalTok{ e}
    \ControlFlowTok{if}\NormalTok{ index[u] }\OperatorTok{<}\NormalTok{ index[v]: }\ControlFlowTok{return}\NormalTok{ np.array([}\FloatTok{1.}\NormalTok{, }\FloatTok{0.}\NormalTok{])}
    \ControlFlowTok{else}\NormalTok{: }\ControlFlowTok{return}\NormalTok{ np.array([}\FloatTok{0.}\NormalTok{, }\FloatTok{-1.}\NormalTok{])}

\KeywordTok{class}\NormalTok{ optscaling_oracle:}
    \KeywordTok{def} \FunctionTok{__init__}\NormalTok{(}\VariableTok{self}\NormalTok{, G):}
        \VariableTok{self}\NormalTok{.network }\OperatorTok{=}\NormalTok{ network_oracle(G, con, pcon)}

    \KeywordTok{def} \FunctionTok{__call__}\NormalTok{(}\VariableTok{self}\NormalTok{, x, t):}
\NormalTok{        cut, feasible }\OperatorTok{=} \VariableTok{self}\NormalTok{.network(x)}
        \ControlFlowTok{if} \KeywordTok{not}\NormalTok{ feasible: }\ControlFlowTok{return}\NormalTok{ cut, t}
\NormalTok{        s }\OperatorTok{=}\NormalTok{ x[}\DecValTok{0}\NormalTok{] }\OperatorTok{-}\NormalTok{ x[}\DecValTok{1}\NormalTok{]}
\NormalTok{        fj }\OperatorTok{=}\NormalTok{ s }\OperatorTok{-}\NormalTok{ t}
        \ControlFlowTok{if}\NormalTok{ fj }\OperatorTok{<} \FloatTok{0.}\NormalTok{:}
\NormalTok{            t }\OperatorTok{=}\NormalTok{ s}
\NormalTok{            fj }\OperatorTok{=} \FloatTok{0.}
        \ControlFlowTok{return}\NormalTok{ (np.array([}\FloatTok{1.}\NormalTok{, }\FloatTok{-1.}\NormalTok{]), fj), t}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Example: clock period \& yield-driven co-optimization}
\protect\hypertarget{example-clock-period-yield-driven-co-optimization}{}

\[\begin{array}{cll}
   \text{minimize} &T_{CP} - w_{\color{blue}\beta} {\color{blue}\beta} \\
   \text{subject to} & u_i - u_j \le T_{CP} + F_{ij}^{-1}(1 - {\color{blue}\beta}), & \forall (i,j) \in E_s \,,\\
                     & u_j - u_i \le F_{ij}^{-1}(1 - {\color{blue}\beta}), & \forall (j,i) \in E_h \,, \\
                     & T_{CP} \ge 0, \, 0 \le {\color{blue}\beta} \le 1 \, , \\
    \text{variables} &T_{CP}, {\color{blue}\beta}, u.
   \end{array}\]

\begin{itemize}
\tightlist
\item
  Note that \(F_{ij}^{-1}(x)\) is not concave in general in \([0, 1]\).
\item
  Fortunately, we are most likely interested in optimizing circuits for
  high yield rather than the low one in practice.
\item
  Therefore, by imposing an additional constraint to \(\beta\), say
  \(\beta \geq 0.8\), the problem becomes convex.
\end{itemize}

\end{frame}

\begin{frame}{Inverse CDF}
\protect\hypertarget{inverse-cdf}{}

\begin{figure}
\centering
\includegraphics{ellipsoid.files/Fig2-b-invcdf.pdf}
\caption{img}
\end{figure}

\end{frame}

\hypertarget{matrix-inequalities}{%
\section{Matrix Inequalities}\label{matrix-inequalities}}

\begin{frame}{Problems With Matrix Inequalities}
\protect\hypertarget{problems-with-matrix-inequalities}{}

Consider the following problem:

\[\begin{array}{ll}
    \text{minimize}    & {\color{purple}t}, \\
    \text{subject to}  & F({\color{blue}x}, {\color{purple}t}) \succeq 0,
\end{array}\]

\begin{itemize}
\tightlist
\item
  \(F({\color{blue}x}, {\color{purple}t})\): a matrix-valued function
\item
  \(A \succeq 0\) denotes \(A\) is positive semidefinite.
\end{itemize}

\end{frame}

\begin{frame}{Problems With Matrix Inequalities}
\protect\hypertarget{problems-with-matrix-inequalities-1}{}

\begin{itemize}
\tightlist
\item
  Recall that a matrix \(A\) is positive semidefinite if and only if
  \(v^\mathsf{T} A v \ge 0\) for all \(v \in \mathbb{R}^N\).
\item
  The problem can be transformed into: \[\begin{array}{ll}
            \text{minimize}      & {\color{purple}t}, \\
            \text{subject to}    & v^\mathsf{T} F({\color{blue}x}, {\color{purple}t}) v \ge 0, \; \forall v \in \mathbb{R}^N
    \end{array}\]
\item
  Consider \(v^\mathsf{T} F({\color{blue}x}, {\color{purple}t}) v\) is concave
  for all \(v \in \mathbb{R}^N\) w. r. t. \({\color{blue}x}\), then the
  above problem is a convex programming.
\item
  Reduce to \emph{semidefinite programming} if
  \(F({\color{blue}x}, {\color{purple}t})\) is linear w.r.t.
  \({\color{blue}x}\), i.e.,
  \(F({\color{blue}x}) = F_0 + x_1 F_1 + \cdots + x_n F_n\)
\end{itemize}

\end{frame}

\begin{frame}{Oracle in Matrix Inequalities}
\protect\hypertarget{oracle-in-matrix-inequalities}{}

The oracle only needs to:

\begin{itemize}
\tightlist
\item
  Perform a \emph{row-based} Cholesky factorization such that
  \(F(x_0, t) = R^\mathsf{T} R\).
\item
  Let \(A_{:p,:p}\) denotes a submatrix
  \(A(1:p, 1:p) \in \mathbb{R}^{p\times p}\).
\item
  If Cholesky factorization fails at row \(p\),

  \begin{itemize}
  \tightlist
  \item
    there exists a vector
    \(e_p = (0, 0, \cdots, 0, 1)^\mathsf{T} \in \mathbb{R}^p\), such that

    \begin{itemize}
    \tightlist
    \item
      \(v = R_{:p,:p}^{-1} e_p\), and
    \item
      \(v^\mathsf{T} F_{:p,:p}(x_0) v < 0\).
    \end{itemize}
  \item
    The cut \((g, h)\) =
    \((-v^\mathsf{T} \partial F_{:p,:p}(x_0) v, -v^\mathsf{T} F_{:p,:p}(x_0) v)\)
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Corresponding Python Code}
\protect\hypertarget{corresponding-python-code-4}{}

\scriptsize

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ lmi_oracle:}
    \CommentTok{''' Oracle for LMI constraint F*x <= B '''}

    \KeywordTok{def} \FunctionTok{__init__}\NormalTok{(}\VariableTok{self}\NormalTok{, F, B):}
        \VariableTok{self}\NormalTok{.F }\OperatorTok{=}\NormalTok{ F}
        \VariableTok{self}\NormalTok{.F0 }\OperatorTok{=}\NormalTok{ B}
        \VariableTok{self}\NormalTok{.A }\OperatorTok{=}\NormalTok{ np.zeros(B.shape)}

    \KeywordTok{def} \FunctionTok{__call__}\NormalTok{(}\VariableTok{self}\NormalTok{, x):}
\NormalTok{        n }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(x)}

        \KeywordTok{def}\NormalTok{ getA(i, j):}
            \VariableTok{self}\NormalTok{.A[i, j] }\OperatorTok{=} \VariableTok{self}\NormalTok{.F0[i, j]}
            \VariableTok{self}\NormalTok{.A[i, j] }\OperatorTok{-=} \BuiltInTok{sum}\NormalTok{(}\VariableTok{self}\NormalTok{.F[k][i, j] }\OperatorTok{*}\NormalTok{ x[k]}
                                \ControlFlowTok{for}\NormalTok{ k }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n))}
            \ControlFlowTok{return} \VariableTok{self}\NormalTok{.A[i, j]}

\NormalTok{        Q }\OperatorTok{=}\NormalTok{ chol_ext(getA, }\BuiltInTok{len}\NormalTok{(}\VariableTok{self}\NormalTok{.A))}
        \ControlFlowTok{if}\NormalTok{ Q.is_spd(): }\ControlFlowTok{return} \VariableTok{None}\NormalTok{, }\DecValTok{1}
\NormalTok{        v }\OperatorTok{=}\NormalTok{ Q.witness()}
\NormalTok{        p }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(v)}
\NormalTok{        g }\OperatorTok{=}\NormalTok{ np.array([v.dot(}\VariableTok{self}\NormalTok{.F[i][:p, :p].dot(v))}
                      \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n)])}
        \ControlFlowTok{return}\NormalTok{ (g, }\FloatTok{1.}\NormalTok{), }\DecValTok{0}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Example: Matrix Norm Minimization}
\protect\hypertarget{example-matrix-norm-minimization}{}

\begin{itemize}
\tightlist
\item
  Let \(A({\color{blue}x}) = A_0 + x_1 A_1 + \cdots + x_n A_n\)
\item
  Problem \(\min_x \| A({\color{blue}x}) \|\) can be reformulated as
  \[\begin{array}{ll}
       \text{minimize}      & {\color{purple}t}, \\
       \text{subject to}    & \left(
   \begin{array}{cc}
    {\color{purple}t}\,I   & A({\color{blue}x}) \\
    A^\mathsf{T}({\color{blue}x}) & {\color{purple}t}\,I
   \end{array} \right) \succeq 0,
   \end{array}\]
\item
  Binary search on \({\color{purple}t}\) can be used for this problem.
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Python Code}
\protect\hypertarget{python-code-1}{}

\scriptsize

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ qmi_oracle:}
    \KeywordTok{def} \FunctionTok{__init__}\NormalTok{(}\VariableTok{self}\NormalTok{, F, F0):}
        \VariableTok{self}\NormalTok{.F }\OperatorTok{=}\NormalTok{ F}\OperatorTok{;} \VariableTok{self}\NormalTok{.F0 }\OperatorTok{=}\NormalTok{ F0}
        \VariableTok{self}\NormalTok{.Fx }\OperatorTok{=}\NormalTok{ np.zeros(F0.shape)}
        \VariableTok{self}\NormalTok{.A }\OperatorTok{=}\NormalTok{ np.zeros(F0.shape)}
        \VariableTok{self}\NormalTok{.t }\OperatorTok{=} \VariableTok{None}\OperatorTok{;} \VariableTok{self}\NormalTok{.count }\OperatorTok{=} \DecValTok{-1}

    \KeywordTok{def}\NormalTok{ update(}\VariableTok{self}\NormalTok{, t): }\VariableTok{self}\NormalTok{.t }\OperatorTok{=}\NormalTok{ t}

    \KeywordTok{def} \FunctionTok{__call__}\NormalTok{(}\VariableTok{self}\NormalTok{, x):}
        \VariableTok{self}\NormalTok{.count }\OperatorTok{=} \DecValTok{-1}\OperatorTok{;}\NormalTok{ nx }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(x)}

        \KeywordTok{def}\NormalTok{ getA(i, j):}
            \ControlFlowTok{if} \VariableTok{self}\NormalTok{.count }\OperatorTok{<}\NormalTok{ i:}
                \VariableTok{self}\NormalTok{.count }\OperatorTok{=}\NormalTok{ i}\OperatorTok{;} \VariableTok{self}\NormalTok{.Fx[i] }\OperatorTok{=} \VariableTok{self}\NormalTok{.F0[i]}
                \VariableTok{self}\NormalTok{.Fx[i] }\OperatorTok{-=} \BuiltInTok{sum}\NormalTok{(}\VariableTok{self}\NormalTok{.F[k][i] }\OperatorTok{*}\NormalTok{ x[k]}
                                  \ControlFlowTok{for}\NormalTok{ k }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(nx))}
            \VariableTok{self}\NormalTok{.A[i, j] }\OperatorTok{=} \OperatorTok{-}\VariableTok{self}\NormalTok{.Fx[i].dot(}\VariableTok{self}\NormalTok{.Fx[j])}
            \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{==}\NormalTok{ j: }\VariableTok{self}\NormalTok{.A[i, j] }\OperatorTok{+=} \VariableTok{self}\NormalTok{.t}
            \ControlFlowTok{return} \VariableTok{self}\NormalTok{.A[i, j]}

\NormalTok{        Q }\OperatorTok{=}\NormalTok{ chol_ext(getA, }\BuiltInTok{len}\NormalTok{(}\VariableTok{self}\NormalTok{.A))}
        \ControlFlowTok{if}\NormalTok{ Q.is_spd(): }\ControlFlowTok{return} \VariableTok{None}\NormalTok{, }\DecValTok{1}
\NormalTok{        v }\OperatorTok{=}\NormalTok{ Q.witness()}\OperatorTok{;}\NormalTok{ p }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(v)}
\NormalTok{        Av }\OperatorTok{=}\NormalTok{ v.dot(}\VariableTok{self}\NormalTok{.Fx[:p])}
\NormalTok{        g }\OperatorTok{=} \FloatTok{-2.}\OperatorTok{*}\NormalTok{np.array([v.dot(}\VariableTok{self}\NormalTok{.F[k][:p]).dot(Av)}
                          \ControlFlowTok{for}\NormalTok{ k }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(nx)])}
        \ControlFlowTok{return}\NormalTok{ (g, }\FloatTok{1.}\NormalTok{), }\DecValTok{0}
\end{Highlighting}
\end{Shaded}

\end{frame}

\begin{frame}{Example: Estimation of Correlation Function}
\protect\hypertarget{example-estimation-of-correlation-function}{}

\[\begin{array}{ll}
   \min_{{\color{blue}\kappa}, p}   & \| \Omega({\color{blue}p}) + {\color{blue}\kappa} I - Y \| \\
   \text{s. t.} & \Omega({\color{blue}p}) \succcurlyeq 0,  {\color{blue}\kappa} \geq 0 \; .\\
 \end{array}\]

\begin{itemize}
\item
  Let \(\rho(h) = \sum_i^n {\color{blue}p}_i \Psi_i(h)\), where

  \begin{itemize}
  \tightlist
  \item
    \(p_i\)’s are the unknown coefficients to be fitted
  \item
    \(\Psi_i\)’s are a family of basis functions.
  \end{itemize}
\item
  The covariance matrix \(\Omega({\color{blue}p})\) can be recast as:

  \[\Omega({\color{blue}p}) = {\color{blue}p}_1 F_1 + \cdots + {\color{blue}p}_n F_n\]

  where \(\{F_k\}_{i,j} =\Psi_k( \| s_j - s_i \|_2)\)
\end{itemize}

\end{frame}

\begin{frame}{Experimental Result}
\protect\hypertarget{experimental-result}{}

\begin{figure}
\centering
\includegraphics{ellipsoid.files/corr_fn.pdf}
\caption{BSpline vs.~Polynomail}
\end{figure}

\end{frame}

\hypertarget{q-a}{%
\section{Q \& A}\label{q-a}}

\end{document}
